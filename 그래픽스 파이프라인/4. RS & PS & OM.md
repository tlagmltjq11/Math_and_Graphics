## Rasterizer
파이프라인의 2단계인 래스터화는 1단계인 정점 처리의 출력을 입력으로 받는다.<br>
정점 처리 단계는 모델링으로부터 얻어진 폴리곤 메쉬의 각 정점들에 여러 변환을 적용하여 클립 공간으로 이동시켰다.<br>
이러한 정점들이 래스터화의 입력으로 들어온다. 래스터화 단계에선 각 정점들을 정점, 선분, 삼각형(폴리곤) 단위로 처리하는데,<br>
보통 삼각형 단위로 처리한다. 그리고 이러한 단위를 **프리미티브(primitive)** 라 한다.<br>
<br>

이렇게 조립되는 각 삼각형들은 최종적으로 우리가 보는 2차원 평면에 그려지게 될텐데, 우리가 보는 화면은 픽셀(pixel)로 구성이 된다.<br>
따라서 **삼각형들을 픽셀로 채워야 하는데, 해당 단계에선 우선 일종의 예비 픽셀인 프래그먼트(fragment)로 채우게 된다.** <br>
프래그먼트를 생성할 땐 각 정점에 할당되었던 여러 데이터(노멀, 텍스처 좌표 등)를 이용(보간)하여 생성한다.<br>
이를 포함하여 래스터화 단계에서 수행되는 작업들을 나열하면 다음과 같다.<br>
<br>

-> **간단히 설명하자면, 3차원으로 표현된 삼각형을 화면에 그려질 일련의 픽셀로 변환하는 단계** <br>
<br>

클리핑(Clipping)<br>
원근 나눗셈(perspective division)<br>
뒷면 제거(back-face culling)<br>
뷰포트 변환(view-port transform)<br>
스캔 변환(sacn transform)<br>
<br>

이제 각각의 요소들에 대해 간단히 살펴보도록 하겠다.<br>
<br>
<br>

3.1 클리핑(clipping)
클리핑은 투영변환 이후의 클립공간볼륨 바깥에 놓인 폴리곤을 잘라 내는 작업을 말합니다. 이전부터 몇 번 언급되었던 이 작업은 바로 이 레스터화 단계에서 일어납니다.

3.2 원근 나눗셈(perspective division).

![원근나눗셈](https://user-images.githubusercontent.com/43705434/120767490-314e3380-c556-11eb-8f1d-5035e2310992.PNG)

현재 단계에서 투영변환을 통해 원근법이 적용된 3차원 물체들은 직육면체 볼륨의 3차원 클리핑 공간에서 정의되어 있습니다. 그러나 우리가 최종적으로 필요한 것은 모니터 화면에 출력될 2차원 사각 영역이죠. 그렇다면 3차원 공간을 어떻게 2차원 공간으로 변환시킬 수 있을까요?

단순히 생각하면 그냥 차원을 줄이면 됩니다. 바로 z좌표로 모든 성분을 나눠버리는 것이지요. 실제 z값은 투영변환행렬을 곱한 후 동차좌표계의 (x,y,z,w)에서 w성분에 저장되어 있기 때문에 투영변환 이후 w에 저장된 값으로 좌표를 나누는 연산을 마치면 원근법 구현이 완료되고 이를 원근 나눗셈이라 부릅니다. 원근 나눗셈이 적용된 이후에는 (x,y,z,w)의 동차 좌표계에서 (x,y,z)의 카테시안 좌표계로 변화게 되는데요 이 때 이를 NDC(normalized device coordinates) 공간이라 부릅니다. 여기서 정규화라는 이름이 붙는 이후는 이 좌표의 xy범위가 [-1,1]이고 z범위가 [0,1]이기 때문입니다.

3.3 뒷면 제거(back-face culling)
다음으로 레스터라이저에서 하는 기능으로 뒷면 제거가 있습니다. 뒷면 제거는 카메라에 등을 돌리고 있어 보이지 않는 폴리곤을 제거하는 작업입니다. 이런 보이지 않는 폴리곤을 주로 뒷면(back-face), 보이는 면을 앞면(front-face)라고 부릅니다. 원리는 간단한데 카메라의 시선벡터 V0가 있고, 폴리곤의 법선벡터 V1이 있다고 가정하면 이 둘이 이루는 각도가 예각인지 둔각인지에 따라 뒷면을 판별할 수 있습니다. 여기서 폴리곤의 법선벡터를 구할 때는 외적(cross product)를 사용하여 구하는데 이 때 외적은 순서에 따라 방향이 다르게 나올 수 있잖아요? Direct3D에서 등장하는 와인딩 오더(시계방향 혹은 반시계)는 이것을 정하는 방법인데 기본적으로 시계 방향으로 감긴 삼각형을 앞면으로, 반시계 방향으로 감긴 삼각형을 뒷면으로 간주하지만 이는 랜더 상태 설정에 따라 변경 가능합니다.

3.4 뷰포트 변환(view-port transform)
컴퓨터 화면 상의 윈도우는 스크린 공간(screen-space)을 갖는데요. 이 스크린 공간 내에 2차원 이미지가 그려질 뷰포트(view-port)가 정의되는데 NDC 공간의 물체들을 스크린 공간으로 이전시키는 변환을 뷰포트 변환이라 합니다.

3.5 스캔 변환(scan transform)
이제 레스터라이저의 마지막 단계인 스캔변환만이 남았습니다. 이전의 변환들은 자세한 사항을 몰라도 프로그래밍 하는데 있어 별다른 영향을 미치지 않지만 이 스캔변환은 랜더링 프로그램에서 직접적인 영향을 미치기 때문에 꽤 중요한 내용입니다. 우선 스캔변환이란 삼각형 하나가 내부에 차지하는 프레그먼트를 생성하는 과정입니다. 좀 더 자세하게 설명하면 개별 삼각형이 차지하는 스크린 공간의 픽셀 위치를 결정하고, 삼각형의 정점별 속성을 보간(interpolation)하여 이를 각 픽셀 위치에 할당하는 일을 수행합니다. 여기서 정점별 속성이란 프로그램마다 다르지면 대체로 position, uv, normal과 같은 값을을 의미합니다. 이때 보간 과정은 하드웨어가 수행하기 떄문에 그에 깔린 수학적 내용을 몰라도 지장은 없지만 대충 설명하자면 삼각형을 구성하는 각 변마다 기울기를 계산하여 모서리를 따라 선형보간(Linear Interpolation)하는 과정을 통해 계산됩니다.


## Pixel Shader
지금까지 한 내용을 다시 복습해보자면 응용프로그램으로 부터 정점버퍼를 입력받아 입력조립기에서 이 정점들을 프리미티브 단위로 조립하고, 각각의 정점은 정점 변환 단계를 거쳐 변환되어 레스터라이저로 넘어갑니다. 레스터화 단계에서는 클리핑을 통해 폴리곤을 잘라내고, 뒷면 제거를 통해 보이지 않을 면을 제거하고, 원근 투영 나눗셈을 하여 원근법을 구현하고, 뷰포트 변환을 통해 NDC상의 물체들을 스크린 공간으로 사상하고, 마지막으로 스캔변환을 통해 삼각형을 구성하는 정점별 속성을 보간하여 내부의 프레그먼트들에게 할당하였습니다. 이제는 각각의 프레그먼트의 색상을 결정하는 일만 남았습니다. 조명을 계산한다던가, 텍스쳐를 입힌다던가 하는 작업을 통해 프래그먼트를 색칠하는 단계를 바로 프래그먼트 처리 단계라 합니다. Direct3D의 세이더 파이프라인에서는 Pixel Shader 단계에서 이러한 일들을 수행합니다.

## Output Merger
아웃풋 머저(OM, output-merger) 스테이지는 파이프라인 상태, 픽셀 쉐이더에 의해 생성된 픽셀 데이터, 렌더 타겟의 요소, 그리고 깊이 / 스텐실 버퍼의 조합을 사용해서 최종적으로 렌더링될 픽셀의 컬러값을 생성한다. (OpenGL의 프래그먼트 연산 과정과 비슷하다) OM 스테이지는 어느 픽셀이 보여져야 할지 결정하고, 최종적인 픽셀 색상을 섞는(blending) 마지막 단계이다.

Pixel vs. Fragment

정확하게 비교를 한 곳이 없는 건지 영어를 못 해서 제대로 해석을 못 하는 건지 찾기가 쉽지가 않다. 출처 4에 따르면 Pixel은 단순히 Screen에 보이는 하나의 Dot을 의미한다. 반면 Fragment는 Framebuffer에 Write(쓰기)를 위해서 그보다 많은 정보를 담고 있다고 한다. 예를 들어 Depth, Alpha (투명도), Stencil, 등 다양한 정보를 모두 포함한 것을 Fragment라고 한다. 그래서 내가 느끼기에는 Pixel이란 우리가 보는 모니터에 보이는 Dot 하나 하나를 의미한다. 예를 들어 RGBA 정보를 표시하는 하나의 Dot이 Pixel이다. Fragment는 특정 물체를 그리는 과정에서 포함하고 있는 모든 정보를 의미하는 것 같다. 위 그림에서 볼 수 있듯이 Fragment는 Pixel의 집합일 수도 있고 Pixel 하나에 다양한 정보를 포함하면 Fragment가 될 수도 있는 것 같다. 만약 공부하다가 더 명확하게 이해가 되면 수정을 하겠다.


## View Port
뷰포트란 **'화면에 표시되는 영역'** 정도로 정의할 수 있다.<br>
우리가 만들어낸 3D공간을 이렇게 생긴 Viewport라는 창문을 통해 보게 되는 것이다.<br>
<br>

뷰포트로의 변환은 프로젝트 윈도우의 좌표를 뷰포트라 불리는 화면의 직사각형으로 변환하는 과정을 말한다.<br>
게임에서의 뷰포트는 보통 직사각형의 전체 화면이 되지만, 윈도우 모드에서 실행하는 경우에는 클라이언트 영역이나 화면의 일부가 될 수도 있다.
뷰포트 사각형은 이를 포함하고 있는 윈도우와 상대적이며, 윈도우 좌표를 이용해 지정된다.<br>
<br>

![뷰포트](https://user-images.githubusercontent.com/43705434/120757388-76209d00-c54b-11eb-922c-4f0dbf612f68.PNG)<br>
<br>

▶ 결론<br>
**ViewPort는 일종의 창문** 이고 3D 그래픽을 구현한다는 것은 이 창문 밖을 바라보는 것처럼 그럴싸하게 보이도록 그림을 그리는 것이다.<br>
즉 관찰자가 창문(ViewPort)밖에 있는 어떤 가상의 정육면체를 바라보고 있다고 믿도록 그럴싸하게 보여주고 싶다면 꼭짓점에서 쏘아진 광선이<br>
창문의 어느 곳을 통과하여 우리 눈으로 들어오는 지를 계산하여 ViewPort의 그 위치에 각각의 빛깔을 찍어주면 된다는 뜻이다.<br>
<br>
<br>

## Rasterize

![레스터라이즈](https://user-images.githubusercontent.com/43705434/120759834-65255b00-c54e-11eb-92b2-09c0b4895e82.PNG)<br>
<br>

위에서 설명했던 Vertex Shader 작업들을 거치고 나면 즉 스크린 좌표로 버텍스들을 변환하게되면, 2D 삼각형들의 리스트를 가지게 된다.<br>
**래스터라이즈 단계는 이러한 삼각형들을 픽셀로 표현해주는 과정** 을 의미한다.<br>
<br>

(vertex 사이 공간은 보간을 통해서 알맞은 픽셀로 표시한다.)<br>
(다른 Object/Mesh (물체) 뒤에 있어서 보이지 않는 픽셀을 제거하는 작업도 수행한다고 한다.)<br>
<br>

-> 추후 Pixel Shader 과정에서 픽셀들에 색을 부여한다.<br>
<br>
<br>
