## Rasterizer
정점 처리 단계를 지난 정점은 이제 랜더링 파이프라인의 다음 단계인 레스터화 단계로 들어갑니다. 우선 정점들은 삼각형 등과 같은 프리미티브(primitive)로 묶여지는데, 이 시점 이후 부터는 프리미티브가 독자적인 개체로 처리됩니다. 삼각형을 예를 들어서 설명하겠습니다. 우선 화면에 그려질 2차원 삼각형의 세 정점 좌표가 결정되면 다음과 같은 일이 일어납니다.

이 삼각형이 포함하는 모든 픽셀마다 프레그먼트가 생성된다.
삼각형의 세 정점에 할당되었던 여러 데이터(position, color, uv …)등은 보간(Interpolation)되어 삼각형 내부의 각각의 프레그먼트에 할당된다.
Direct3D에서는 이러한 과정을 통틀어서 레스터라이저(resterizer)라고 부릅니다. 이 레스터라이저는 고정 파이프라인 단계로 프로그래밍이 불가능하여 하드웨어 자체 알고리즘을 통해 동작하며,

클리핑(Clipping)
원근 나눗셈(perspective division)
뒷면 제거(back-face culling)
뷰포트 변환(view-port transform)
스캔 변환(sacn transform)
등의 요소로 구성됩니다. 이제 각각의 요소들에 대해 살펴보도록 하겠습니다.

3.1 클리핑(clipping)
클리핑은 투영변환 이후의 클립공간볼륨 바깥에 놓인 폴리곤을 잘라 내는 작업을 말합니다. 이전부터 몇 번 언급되었던 이 작업은 바로 이 레스터화 단계에서 일어납니다.

3.2 원근 나눗셈(perspective division).

![원근나눗셈](https://user-images.githubusercontent.com/43705434/120767490-314e3380-c556-11eb-8f1d-5035e2310992.PNG)

현재 단계에서 투영변환을 통해 원근법이 적용된 3차원 물체들은 직육면체 볼륨의 3차원 클리핑 공간에서 정의되어 있습니다. 그러나 우리가 최종적으로 필요한 것은 모니터 화면에 출력될 2차원 사각 영역이죠. 그렇다면 3차원 공간을 어떻게 2차원 공간으로 변환시킬 수 있을까요?

단순히 생각하면 그냥 차원을 줄이면 됩니다. 바로 z좌표로 모든 성분을 나눠버리는 것이지요. 실제 z값은 투영변환행렬을 곱한 후 동차좌표계의 (x,y,z,w)에서 w성분에 저장되어 있기 때문에 투영변환 이후 w에 저장된 값으로 좌표를 나누는 연산을 마치면 원근법 구현이 완료되고 이를 원근 나눗셈이라 부릅니다. 원근 나눗셈이 적용된 이후에는 (x,y,z,w)의 동차 좌표계에서 (x,y,z)의 카테시안 좌표계로 변화게 되는데요 이 때 이를 NDC(normalized device coordinates) 공간이라 부릅니다. 여기서 정규화라는 이름이 붙는 이후는 이 좌표의 xy범위가 [-1,1]이고 z범위가 [0,1]이기 때문입니다.

3.3 뒷면 제거(back-face culling)
다음으로 레스터라이저에서 하는 기능으로 뒷면 제거가 있습니다. 뒷면 제거는 카메라에 등을 돌리고 있어 보이지 않는 폴리곤을 제거하는 작업입니다. 이런 보이지 않는 폴리곤을 주로 뒷면(back-face), 보이는 면을 앞면(front-face)라고 부릅니다. 원리는 간단한데 카메라의 시선벡터 V0가 있고, 폴리곤의 법선벡터 V1이 있다고 가정하면 이 둘이 이루는 각도가 예각인지 둔각인지에 따라 뒷면을 판별할 수 있습니다. 여기서 폴리곤의 법선벡터를 구할 때는 외적(cross product)를 사용하여 구하는데 이 때 외적은 순서에 따라 방향이 다르게 나올 수 있잖아요? Direct3D에서 등장하는 와인딩 오더(시계방향 혹은 반시계)는 이것을 정하는 방법인데 기본적으로 시계 방향으로 감긴 삼각형을 앞면으로, 반시계 방향으로 감긴 삼각형을 뒷면으로 간주하지만 이는 랜더 상태 설정에 따라 변경 가능합니다.

3.4 뷰포트 변환(view-port transform)
컴퓨터 화면 상의 윈도우는 스크린 공간(screen-space)을 갖는데요. 이 스크린 공간 내에 2차원 이미지가 그려질 뷰포트(view-port)가 정의되는데 NDC 공간의 물체들을 스크린 공간으로 이전시키는 변환을 뷰포트 변환이라 합니다.

3.5 스캔 변환(scan transform)
이제 레스터라이저의 마지막 단계인 스캔변환만이 남았습니다. 이전의 변환들은 자세한 사항을 몰라도 프로그래밍 하는데 있어 별다른 영향을 미치지 않지만 이 스캔변환은 랜더링 프로그램에서 직접적인 영향을 미치기 때문에 꽤 중요한 내용입니다. 우선 스캔변환이란 삼각형 하나가 내부에 차지하는 프레그먼트를 생성하는 과정입니다. 좀 더 자세하게 설명하면 개별 삼각형이 차지하는 스크린 공간의 픽셀 위치를 결정하고, 삼각형의 정점별 속성을 보간(interpolation)하여 이를 각 픽셀 위치에 할당하는 일을 수행합니다. 여기서 정점별 속성이란 프로그램마다 다르지면 대체로 position, uv, normal과 같은 값을을 의미합니다. 이때 보간 과정은 하드웨어가 수행하기 떄문에 그에 깔린 수학적 내용을 몰라도 지장은 없지만 대충 설명하자면 삼각형을 구성하는 각 변마다 기울기를 계산하여 모서리를 따라 선형보간(Linear Interpolation)하는 과정을 통해 계산됩니다.


## Pixel Shader
지금까지 한 내용을 다시 복습해보자면 응용프로그램으로 부터 정점버퍼를 입력받아 입력조립기에서 이 정점들을 프리미티브 단위로 조립하고, 각각의 정점은 정점 변환 단계를 거쳐 변환되어 레스터라이저로 넘어갑니다. 레스터화 단계에서는 클리핑을 통해 폴리곤을 잘라내고, 뒷면 제거를 통해 보이지 않을 면을 제거하고, 원근 투영 나눗셈을 하여 원근법을 구현하고, 뷰포트 변환을 통해 NDC상의 물체들을 스크린 공간으로 사상하고, 마지막으로 스캔변환을 통해 삼각형을 구성하는 정점별 속성을 보간하여 내부의 프레그먼트들에게 할당하였습니다. 이제는 각각의 프레그먼트의 색상을 결정하는 일만 남았습니다. 조명을 계산한다던가, 텍스쳐를 입힌다던가 하는 작업을 통해 프래그먼트를 색칠하는 단계를 바로 프래그먼트 처리 단계라 합니다. Direct3D의 세이더 파이프라인에서는 Pixel Shader 단계에서 이러한 일들을 수행합니다.

## Output Merger
아웃풋 머저(OM, output-merger) 스테이지는 파이프라인 상태, 픽셀 쉐이더에 의해 생성된 픽셀 데이터, 렌더 타겟의 요소, 그리고 깊이 / 스텐실 버퍼의 조합을 사용해서 최종적으로 렌더링될 픽셀의 컬러값을 생성한다. (OpenGL의 프래그먼트 연산 과정과 비슷하다) OM 스테이지는 어느 픽셀이 보여져야 할지 결정하고, 최종적인 픽셀 색상을 섞는(blending) 마지막 단계이다.

Pixel vs. Fragment

정확하게 비교를 한 곳이 없는 건지 영어를 못 해서 제대로 해석을 못 하는 건지 찾기가 쉽지가 않다. 출처 4에 따르면 Pixel은 단순히 Screen에 보이는 하나의 Dot을 의미한다. 반면 Fragment는 Framebuffer에 Write(쓰기)를 위해서 그보다 많은 정보를 담고 있다고 한다. 예를 들어 Depth, Alpha (투명도), Stencil, 등 다양한 정보를 모두 포함한 것을 Fragment라고 한다. 그래서 내가 느끼기에는 Pixel이란 우리가 보는 모니터에 보이는 Dot 하나 하나를 의미한다. 예를 들어 RGBA 정보를 표시하는 하나의 Dot이 Pixel이다. Fragment는 특정 물체를 그리는 과정에서 포함하고 있는 모든 정보를 의미하는 것 같다. 위 그림에서 볼 수 있듯이 Fragment는 Pixel의 집합일 수도 있고 Pixel 하나에 다양한 정보를 포함하면 Fragment가 될 수도 있는 것 같다. 만약 공부하다가 더 명확하게 이해가 되면 수정을 하겠다.


https://jidon333.github.io/blog/Rendering-pipeline
https://mkblog.co.kr/2018/08/11/gpu-graphics-pipeline/
https://celdee.tistory.com/573
