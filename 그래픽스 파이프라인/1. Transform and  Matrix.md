## Transform and Matrix
<br>

<img src="https://user-images.githubusercontent.com/43705434/120307111-919e6480-c30d-11eb-9324-a350b6005633.PNG" width="350" height="150"><br>
3차원 공간에서 위치와 방향을 갖는 벡터는 선형변환(Affine 변환)을 통해 **이동, 회전, 스케일**이 가능하다는 것을 게임수학 내용들에서 배울 수 있었다.
즉 특정 행렬과의 곱셈을 통해서 이동, 회전, 스케일링 등이 가능하다는 것이다.<br>
(행렬은 여러 개의 연립방정식을 하나로 표현할 수 있는 강력한 도구)<br>
<br>
<br>

![정점프로세싱](https://user-images.githubusercontent.com/43705434/120307115-9236fb00-c30d-11eb-8ebc-f74465320221.PNG)<br>
Unity의 Transform 시스템이 이러한 행렬 곱셈의 프로세스로 이루어져 있다.<br>
그래픽스 파이프라인 과정 중 **정점 파이프라인 과정** 이있는데, 쉽게말하면 가상 3D공간을 모니터의 2D공간으로 변환하는 과정이다.<br>
**로컬좌표계 -> 월드좌표계 -> 카메라좌표계 -> 투영좌표계 -> 뷰포트** 와 같이 프로세스가 구성되어 있으며<br>
여기서 월드좌표계로의 변환을 유니티의 **트랜스폼** 컴포넌트가 담당하고 있으며, 그외 카메라, 투영, 뷰포트 변환은 **카메라** 컴포넌트가 담당한다.<br>
<br>

▶ 지금부터 월드좌표계로의 변환을 알아보자.<br>
<br>
<br>

## Local and World Space
1. 로컬좌표계<br>
![로컬좌표계](https://user-images.githubusercontent.com/43705434/120309094-c90e1080-c30f-11eb-82e5-d4dc9297221c.PNG)<br>
모델링 스페이스라고도 불리며 3D모델을 구설할 때 오브젝트 자신의 기준점을 원점으로 한 좌표계를 말한다.<br>
<br>

2. 월드좌표계<br>
![로컬투월드좌표계](https://user-images.githubusercontent.com/43705434/120309092-c8757a00-c30f-11eb-8528-ea680992c894.PNG)<br>
각각의 오브젝트들이 월드의 원점을 기준으로하고 오브젝트의 상대적 위치를 표현하기 위한 좌표계이다.<br>
위 그림은 로컬좌표계를 월드좌표계로 변환시킨 예시이다.<br>
<br>

## 동차좌표계
우선 알아야 할 것이 **동차좌표계**에 대한 개념이다.<br>
동차좌표계란 어떤 목적을 위해 한 차원의 좌표(n)를 추가한 좌표 (n+1)로 표현을 하는 것을 동차 좌표계다.<br>
즉, 유니티에서 3차원의 좌표에 w를 더해 4차원의 좌표 (x,y,z,w)와 같이 표현하는 것을 의미한다.<br>
<br>

▶ 이러한 동차좌표계를 왜 사용하는 것일까?<br>
<br>

✔️ **이유 1 : 4 x 4 Matrix 연산을 위함.**<br>
이런 동차좌표계를 사용하는데에는 여러 이유가 있겠지만, 가장 단편적인 이유는 **이동** 과 관련된 부분 때문이다.<br>
![좌표덧셈](https://user-images.githubusercontent.com/43705434/120304360-af1dff00-c30a-11eb-987c-be2750e31efb.PNG)<br>
이동은 위와 같이 기존 좌표에 상수를 더하여 벡터를 이동시키는 것을 의미하는데, 행렬과 벡터의 곱셈으로 표현이 안된다.<br>
<br>

![이동행렬](https://user-images.githubusercontent.com/43705434/120304347-ad543b80-c30a-11eb-898d-e3f2e519b290.PNG)<br>
행렬의 곱으로 각 좌표에 상수를 더하기 위해선 어쩔 수 없이 좌표 하나를 추가하여 4x4행렬과 4열을 가진 열벡터를 만들어줘야 한다.<br>
위와 같이 벡터의 마지막 행인 1이 dx, dy, dz와 곱해져 각 좌표에 더해질 수 있다.<br>
<br>

**이동 행렬이 이와 같이 동차좌표계를 사용하기 때문에, 스케일, 회전 또한 동차좌표계로 표현하여야만 서로의 곱셈이 가능해진다.<br>
따라서 모든 변환 행렬은 4x4 행렬을 사용하게 된다.**<br>
(사실 아핀공간, 아핀변환의 관점에서 바라봐야 제대로 된 해석이 된다. 아핀공간이란 **위치** 를 나타내기 위한 **점** 이라는 개념이 도입된 공간)<br>
**아핀변환** : Transformation 은 컴퓨터 그래픽스, 특히 3D 렌더링에서 모델을 표현하는데 있어서 중요한 개념 중 하나이다. 모델은 여러 정점(vertex)들로 이루어져 있는데, 
정점의 좌표는 위치벡터로써 표현된다. 이렇게 표현되는 모델을 3D 월드좌표상의 원하는 위치에 표현해주기 위해선 모든 정점들에 대해서 원하는 좌표에 맞게 위치벡터를 수정해줘야 한다. 
이 상황에서 수학적으로 '잘' 연산을 해주면 이동(translation), 크기변환(scaling), 회전(rotation)등을 통해 원하는 위치에 원하는 크기, 알맞은 돌림(?) 으로 모델을 움직여줄 수 있다.
이러한 변환을 아핀변환(affine transformation) 이라 한다.<br>
출처: https://alleysark.tistory.com/209 [앨리삵]<br>
->> Affine : https://luv-n-interest.tistory.com/810 , https://blog.daum.net/shksjy/229 , https://alleysark.tistory.com/209 <br>
<br>
<br>

✔️ **이유 2 : 벡터와 점을 구분짓기 위함.**<br>
벡터 공간의 한 벡터 u(1,2,3)과 아핀 공간의 한 점 p(1,2,3)은 분명 다른 개념이지만, 컴퓨터는 이를 다르게 해석할 수 없다.<br>
그렇기에 w값을 통해서 구분지어줘야 한다.<br>
<br>

3차원 아핀 공간의 점 p(1,2,3), 점 q(2,4,6), 벡터 u(1,2,3), 벡터 v(2,4,6) 4가지를 가지고 생각해보자.<br>
아핀 공간에서 점 p와 점 q는 다르지만 벡터 u와 벡터 v는 같다.<br>
<br>

**벡터 = 0**<br>
동차 좌표계(x, y, z,ω)로 벡터 u, v를 나타냈을때 ω값으로 0 을 주면 u(1,2,3,0), v(2,4,6,0) 이렇게 나타 낼 수 있고<br>
v의 모든 인자를 2로 나누면 u,v 모두 (1,2,3,0)이므로 같은 벡터임을 알 수 있다.<br>
ω값으로 0을 주게 되면 (x, y, z)의 비율이 같으면 모두 같은 벡터로 볼 수 있다는 것.<br>
<br>

**점 = 1**<br>
점 p 점 q가 다르기 때문에 점 q의 x, y, z값을 2로 나누었을 때 4번째 인자 ω의 값이 점 p와 달라야 두 점이 다르다고 나타 낼 수 있다.<br>
따라서 w값으로 0이 아닌 특정한 값을 기준으로 정해주어야 하고, 1을 사용하기로 기준을 정해 놓았다.<br>
그래서 (2,4,6,1)을 2로 나누면 (1,2,3,1/2)이므로 (1,2,3,1)과 다른 점이다.<br>
(1,2,3,1)과 (2,4,6,2)는 모두 3차원의 점(1,2,3)이다.<br>
<br>

점은 위치의 개념이기에 원점으로 부터의 상대적인 위치로 계산된다. 즉 원점으로 멀어지거나 가까워지거나..<br>
반면 벡터는 원점과 상관없이 그 자체로 변환된다.<br>
![점과 벡터의 차이](https://user-images.githubusercontent.com/43705434/120304352-adecd200-c30a-11eb-811e-950b3f453fd0.PNG)<br>
![점과 벡터의 차이 2](https://user-images.githubusercontent.com/43705434/120304357-ae856880-c30a-11eb-8306-ff499b83318b.PNG)<br>
<br>
<br>

이유 3 : 원근투영을 위함.<br>
추후 업데이트<br>
<br>
<br>

## World Transform (월드변환)
<br>
▶ Unity는 열기준 행렬이다.<br>

<img src="https://user-images.githubusercontent.com/43705434/120440689-c4546580-c3be-11eb-9005-6409c0727392.PNG" width="250" height="250"><br>

고로 변환행렬의 **1열은 x축 2열은 y축 3열은 z축 4열은 포지션값** 을 의미한다.<br>
이때 회전값은 단위벡터로 방향만 나타내고 있으며, 여기에 스칼라곲을 곱해준것이 스케일링값이 된다.<br>
(열기준 행렬이기 때문에 벡터도 열기준으로 바꾼 후 행렬 x 벡터의 형태로 계산한다.)<br>
<br>
<br>

위 동차좌표계 설명에서 봤듯이, 4x4 행렬의 곱셈을 통해 월드좌표계로 변환된다.<br>

✔️ **Scaling** <br>
아래 연산은 벡터 (x,y,z)를 각각 sx, sy, sz만큼 실수배를 하여 축소 또는 확대를 한다.<br>
![스케일변환행렬](https://user-images.githubusercontent.com/43705434/120305131-631f8a00-c30b-11eb-904a-b4edd9c61cb0.PNG)<br>
<br>

✔️ **Rotation** <br>
아래 행렬들은 각각 z, x, y축을 중심으로 세타만큼 회전시키는 행렬이다.<br>
![회전행렬](https://user-images.githubusercontent.com/43705434/120311818-eabcc700-c312-11eb-9079-4197c16b1856.PNG)<br>
<br>
<br>

▶ 이러한 회전행렬들은 삼각함수의 덧셈정리에 의해 다음과 같이 증명(**내적이용**)된다. <br>

<img src="https://user-images.githubusercontent.com/43705434/120444692-d2a48080-c3c2-11eb-96a9-a76363831d02.PNG" width="420" height="600"><br>
<br>

위처럼 **내적을 통한 사잇각(θ)을 이용해서** cos(α-β) = cosαcosβ + sinαsinβ 라는 식을 얻을 수 있다.<br>
cos(α+β)는 cos(α -(-β))로 취급할 수 있기에 이를 풀어보면 cos(α+β) = cosαcosβ - sinαsinβ가 된다.<br>
-> **sinθ = -sinθ 인 이유는 음의 각도로 가게되면 y값은 -가 되기 때문!, 반면 cosθ는 여전히 양수다.** <br>
<br>

▶ cosθ 덧셈 공식<br>
1. cos(α-β) = cosαcosβ + sinαsinβ
2. cos(α+β) = cosαcosβ - sinαsinβ
<br>
<br>


![코사사인차이](https://user-images.githubusercontent.com/43705434/120447945-07fe9d80-c3c6-11eb-8286-805de6bd52f7.PNG)<br>
<br>

sin같은 경우 그래프를 확인해보면 **cos과 𝝿/2 만큼 차이** 난다는 것을 알 수 있다.<br>
이 점을 이용해서 sin(α+β)를 풀어보면 cos(𝝿/2 -(α+β))가 되고 이 식은 cos((𝝿/2 -α) -β)가 된다.<br>
이 식을 위에서 구한 공식처럼 풀어내면 cos(𝝿/2 -α)cosβ + sin(𝝿/2 -α)sinβ가 된다.<br>
여기서 cos(𝝿/2 -α)는 sinα가 되고 sin(𝝿/2 -α)는 cosα가 된다. (𝝿/2 차이기 때문)<br>
최종적으로 sin(α+β) = sinαcosβ + cosαsinβ가 된다.<br>
<br>

sin(α-β) = sin(α -(-β))이기 때문에 sinαcos(-β) + cosαsin(-β)가 된다.<br>
이 식은 sinαcosβ - cosαsinβ로 나타낼 수 있다.<br>
<br>

▶ sinθ 덧셈 공식<br>
1. sin(α+β) = sinαcosβ + cosαsinβ
2. sin(α-β) = sinαcosβ - cosαsinβ
<br>
<br>

▶ 위 공식들을 이용하여 **Z축 회전행렬** 을 증명해보자.<br>

![z축회전행렬1](https://user-images.githubusercontent.com/43705434/120450806-c4a72d80-c3cb-11eb-9def-db59fe08c72b.PNG)<br>
<br>

벡터 Q를 P까지 z축 회전하는 상황을 가정해보면 위와 같은 그림일 것이다.<br>
그림에서 볼 수 있듯이 회전한 후의 벡터의 성분은 다음과 같다.<br>
Px = cos(α+β) = cosαcosβ - sinαsinβ<br>
Py = sin(α+β) = sinαcosβ + cosαsinβ<br>
<br>

여기서 Q의 성분은 Qx = cosβ, Qy = sinβ이기 때문에 위 성분식에 대입시켜줄 수 있게된다.<br>
Px = cosαQx - sinαQy + 0<br>
Py = sinαQx + cosαQy + 0<br>
즉 위와 같이 표현할 수 있게되고 위 식을 행렬로 표현하면 다음과 같아진다.<br>

![z축회전행렬2](https://user-images.githubusercontent.com/43705434/120450798-c2dd6a00-c3cb-11eb-8228-49fe828ebb85.PNG)<br>
<br>

-> **벡터 Q에 해당 회전행렬을 곱해주면 벡터 P가 된다는 의미 즉 z축 회전이 수행된다는 의미가 된다.** <br>
이로써 z축 회전행렬의 증명이 완료되었고, x, y축 또한 위와 같은 방식으로 증명이 가능하다.<br>
<br>
<br>

✔️ **Translation** <br>
이동은 아래와 같이 기존 좌표에 상수를 더하여 이동시킨다.<br>
![위치행렬](https://user-images.githubusercontent.com/43705434/120305132-631f8a00-c30b-11eb-94ad-40f983886436.PNG)<br>
<br>

✔️ **최종 변환행렬 T** <br>
T는 **Scaling * Rotation(x, y, z) * Translation 순서** 로 곱해줘야한다.<br>
(주의! 행렬의 곱셈은 교환법칙이 성립하지않는다.)<br>
<br>

이유 : 스케일 변환은 회전 변환에 영향을 받고 또한, 회전 변환은 이동 변환에 영향을 받기 때문이다.<br>
아래 그림과 같이 이동 변환 후 회전 변환을 하면 객체가 이동 된 지점을 기준으로 회전하기 때문에 위치가 달라진다.<br>
![T계산순서이유](https://user-images.githubusercontent.com/43705434/120311287-476bb200-c312-11eb-9b93-71e09d9ba015.PNG)<br>
<br>

▶ 해당 변환행렬 T를 로컬(버텍스들)에 곱해주며 최종적으로 월드좌표를 구할 수 있게된다.<br>
-> **즉 Transform 컴포넌트에 넣어준 (위치, 회전, 스케일링)값을 토대로 변환행렬이 계산되며 이 행렬 T를**<br>
-> **로컬공간에있는 각 버텍스(모델의 중심점과의 상대적인 위치)에 곱해줌으로써 오브젝트가 월드공간에 배치된다.**<br>
-> Unity에서 transform.localToWorldMatrix로 확인할 수 있다.<br>
<br>
<br>

**tip. 계층구조**<br>
계층구조 상 부모의 위치를 변경해주면 부모의 변경된 변환행렬이 자식에게도 곱해지기 때문에 함께 움직인다.<br>
<br>
<br>

**tip. 역행렬**<br>
정방행렬이고 직교행렬이라면 전치행렬이 역행렬과 같다는 사실을 게임수학 행렬파트에서 배웠을 것이다.<br>
이 사실을 변환행렬에 적용하게되면 회전행렬 부분에 적용할 수 있을 것이다.<br>
**회전행렬** 은 정방행렬이며 직교행렬이기에 역행렬은 전치로 쉽게 구할 수 있다.<br>
**이동행렬** 의 역행렬은 간단하게도 원래 위치로 되돌리면 되기에 이동값에 -를 붙여주며 간단하게 구할 수 있다.<br>

![역행렬](https://user-images.githubusercontent.com/43705434/120440687-c4546580-c3be-11eb-833b-fa40e40a7a07.PNG)<br>

고로 최종 변환행렬 T의 역행렬은 위와 같이 정의된다.<br>
T의 역행렬 = 회전역행렬(전치행렬) x 이동역행렬(- 붙여준것)<br>
여기서 스케일은 회전역행렬에 함께 포함되는데 **스케일값의 역수** 를 곱해주며 원래의 스케일로 되돌리면 된다.<br>
<br>

아래 코드가 실제 변환행렬 T의 역행렬을 구하는 코드이다.<br>
스케일을 되돌리기 위해 v.normalize / v.magnitude를 넣어주는 것을 볼 수 있다.<br>

```c#
public Matrix4x4 MakeInverseMatrix(Matrix4x4 matrix)
{
  Matrix4x4 invRot = Matrix4x4.identity;
  
  //회전 및 스케일행렬의 역행렬을 전치 및 스케일값의 역수를 곱해줌으로써 구한다.
  for(int i=0; i<3; i++)
  {
    Vector4 v = matrix.GetColumn(i);
    invRot.SetRow(i, v.normalized / v.magnitude);
  }
  
  //이동행렬의 역행렬을 -를 붙여줌으로써 구한다.
  Matrix4x4 invTrans = Matrix4x4.identity;
  invTrans.m03 = -matrix.m03;
  invTrans.m13 = -matrix.m13;
  invTrans.m23 = -matrix.m23;
  
  //최종 변환행렬로 Combine
  return invRot * invTrans;
}
```

<br>
<br>

## View Space
월드공간 좌표에서 카메라를 중심으로 한, 카메라 공간 좌표로 변환해 주는 것을 **뷰 변환** 이라 하며<br>
이러한 공간을 **뷰 공간** 이라 칭한다. 이러한 뷰 좌표계의 원점은 카메라의 위치가 된다.<br>
<br>

![뷰공간](https://user-images.githubusercontent.com/43705434/120469400-3cca1f00-c3dd-11eb-9add-567b95f9760a.PNG)<br>
<br>

▶ 뷰 변환이 필요한 이유와 설명
1. 스크린에 표시되는 영상은 장면을 바라보는 관찰자의 위치와 시선 방향에 따라 결정된다.
2. 관찰자의 눈은 카메라와 동일하다.
3. 카메라의 위치와 방향은 관찰자가 보는 장면의 영상을 결정한다.
4. 카메라와 모든 물체들은 월드공간에서 정의된다.
5. 카메라에서 보이는 장면을 정하고, 이로부터 스크린에 표시할 영상을 계산해내기 위해서는 월드공간을 카메라 중심의 공간으로 변환하는 것이 필요하다.
6. 카메라를 중심으로 하는 공간, 관찰자를 중심으로 하는 공간을 **뷰 공간** 이라 한다.
7. 뷰 공간은 카메라가 좌표계의 중심(원점)이 되고, 시선 방향이 z축의 음(GL마다 다름)의 방향과 일치한다.
8. 뷰 변환이 적용된 이후에는 월드공간에서 표현된 카메라와 모든 물체들이 카메라 공간안에 놓이게 된다.
<br>
<br>

<img src="https://user-images.githubusercontent.com/43705434/120469378-350a7a80-c3dd-11eb-8d19-fd6cf326d866.PNG" width="350" height="250"><br>
<br>
뷰 행렬은 카메라의 월드공간 변환행렬의 역행렬이다.<br>
다만! z축은 -를 붙인 상태로 역행렬을 계산해야한다.<br>
-> 같은 좌표축이면 카메라에 물체가 비춰지지 않을 것임.<br> 
-> z축을 반대로해야 카메라와 오브젝트가 같은 방향을 보는 상황을 방지하고 마주보게하여 카메라에 보여질 수 있을 것임.<br>
-> 뷰 행렬은 camera.worldToCameraMatrix로 확인가능.<br>

카메라의 y값을 위로 올리면 카메라를 통해서 바라보는 사물들은 반대로 아래로 내려가고<br>
위로 회전해도 오브젝트는 카메라 기준 아래쪽으로 배치가 바뀌어야 한다.<br>
<br>

추후 업데이트<br>
<br>
<br>

## Projection Space
월드 좌표계와 카메라 좌표계는 모두 3차원 좌표계이다. 우리가 디스플레이로 확인하게 되는 렌더링 결과들은 모두 2차원의 화면이다.<br>
이는 3차원 좌표계를 2차원 좌표계로 바꾸는 변환이 필요하다는 것을 알 수 있다.<br>
즉 3D 장면의 2D 표현을 얻는 과정이 남아있다. 이와 같이 n 차원에서 n-1 차원을 얻는 과정을 투영(projection)이라 한다.<br>
(실제 우리가 모니터에서 바라보는 모습, 렌더링되는 모습의 공간으로 배치된다는 의미임.)<br>
이러한 투영은 크게 원근, 직교투영으로 나뉜다.<br>
<br>
<br>

![원근투영](https://user-images.githubusercontent.com/43705434/120469384-376cd480-c3dd-11eb-8cfb-72b91fd955ec.PNG)<br>
<br>

▶ 원근 투영(perspective projection)<br>
즉, 카메라에서 멀리 떨어진 물체는 가까운 물체에 비해 작게 나타난다. 이와 같은 타입의 투영은 3D 장면을 2D 이미지로 표현하는 데 가장 적합하다.<br>
<br>
<br>

![직교투영](https://user-images.githubusercontent.com/43705434/120469390-389e0180-c3dd-11eb-9d1e-9bfe775ffdb8.PNG)<br>
<br>

▶ 직교 투영(orthographic projection)<br>
원근법을 배제하고 투영시키는것. 2D 게임을 표현할때 가장 적합하다.<br>
투영 변환행렬은 camera.projectionMatrix로 확인가능.<br>
<br>
<br>

## View Port
뷰포트란 '화면에 표시되는 영역' 정도로 정의할 수 있다.<br>
우리가 만들어낸 3D공간을 이렇게 생긴 Viewport라는 창문을 통해 보게 되는 것이다.<br>
<br>

뷰포트로의 변환은 프로젝트 윈도우의 좌표를 뷰포트라 불리는 화면의 직사각형으로 변환하는 과정을 말한다.<br>
게임에서의 뷰포트는 보통 직사각형의 전체 화면이 되지만, 윈도우 모드에서 실행하는 경우에는 클라이언트 영역이나 화면의 일부가 될 수도 있다.<br>
뷰포트 사각형은 이를 포함하고 있는 윈도우와 상대적이며, 윈도우 좌표를 이용해 지정된다.<br>
<br>

![뷰포트](https://user-images.githubusercontent.com/43705434/120757388-76209d00-c54b-11eb-922c-4f0dbf612f68.PNG)<br>
<br>

▶ 결론
ViewPort는 일종의 창문이고 3D 그래픽을 구현한다는 것은 이 창문 밖을 바라보는 것처럼 그럴싸하게 보이도록 그림을 그리는 것이다.<br>
즉 관찰자가 창문(ViewPort)밖에 있는 어떤 가상의 정육면체를 바라보고 있다고 믿도록 그럴싸하게 보여주고 싶다면 꼭짓점에서 쏘아진 광선이<br>
창문의 어느 곳을 통과하여 우리 눈으로 들어오는 지를 계산하여 ViewPort의 그 위치에 각각의 빛깔을 찍어주면 된다는 뜻이다.<br>
<br>
<br>

## 참조링크
https://woo-dev.tistory.com/168 <br>
https://luv-n-interest.tistory.com/810 <br>
https://blog.daum.net/shksjy/229 <br>
https://ckhyeok.tistory.com/9 <br>
https://m.blog.naver.com/m_jackson_ko/221362082753 (view space) <br>
https://mooneegee.blogspot.com/2015/02/directx9-world-transform-viewing.html <br>
https://dlgnlfus.tistory.com/135 (Projection) <br>
https://ludens92.tistory.com/6 (viewport) <br>
