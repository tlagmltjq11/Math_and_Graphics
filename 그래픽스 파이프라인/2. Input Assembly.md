## Input Assembly

![인풋어쎔](https://user-images.githubusercontent.com/43705434/120779419-036eec00-c562-11eb-84b0-b42e3f914c14.PNG)<br>
<br>

▶ 3차원 모델 하나를 3차원 세상에 나타내기 위해서는 가장 먼저 무엇을 해야 할까?<br>
우선 모델의 정보를 GPU로 전달해야 한다. 여기서 모델은 삼각형(폴리곤)의 집합을 의미하고, 삼각형은 정점(Vertex) 3개의 집합이기 때문에<br>
실제로 DX와 같은 그래픽스 라이브러리에서는 모델의 최소단위인 **정점들의 집합을 GPU로 전달하게 된다.** <br>
이 때 이 정점들을 **운반하는 자료구조를 정점 버퍼** 라고 한다.<br>
<br>
<br>

▶ 정점 정보만으로 도형을 구성할 수 있을까?<br>
정점 버퍼는 그냥 정점들을 연속적인 메모리에 저장하는 자료구조에 불과하기 때문에 실제로 GPU에서는 이러한 정점들을 이용하여<br>
**어떤 도형을 만들어야 할 지 정보가 필요** 하다. 예를 들면 정점을 두 개씩 엮어서 선분을 구성할 수도 있고, 세 개씩 엮어서<br>
삼각형을 구성할 수도 있다. 이러한 기본도형을 형성하는 방식을 알려주는데 쓰이는 수단으로 Direct3D에서는 **Primitive Topology**라는 형태를 이용한다.
이 프리미티브 토폴로지는 해석하자면 “위상 구조”라 할 수 있는데 DX11 에서는 point list, line list, triangle list 등이 있다.<br>
여기서 Triangle list를 선택하여 기본도형을 삼각형으로 선택했다고 가정 해 보자. 그러면 이제 모델 하나를 형성하기 위해서 GPU에서 수많은 삼각형들을
이어 붙이기만 하면 되는 것이다.<br>
<br>

![인풋어셈블리2](https://user-images.githubusercontent.com/43705434/120767498-327f6080-c556-11eb-8a07-d8fd23b468ee.PNG)<br>
<br>

위상 구조 추후 업데이트<br>
<br>
<br>

▶ **입력 조립기 단계(Input Assemble) 에서는 이런 정점들을 읽어서 삼각형과 같은 기본 도형으로 조립하는 일을 한다. 그래서 입력 조립 단계인 것.**<br>
<br>
<br>

▶ Index Buffer <br>
정점 버퍼와 같이 등장하는 용어로 **인덱스 버퍼(Index Buffer)** 라는 것이 있다.<br>
이 인덱스 버퍼는 쉽게 생각하면 정점들의 인덱스를 저장하고 있는 버퍼라 할 수 있는데 사각형을 예를 들어 생각 해보자.<br>
사각형 하나를 그리기 위해서 이것을 최소 단위의 도형(삼각형)으로 쪼개면 삼각형 두 개가 생긴다.<br>
그렇다면 이 삼각형 두 개를 그리기 위해서는 당연히 2x3 = 6개의 정점이 필요 할 것이다.<br>
그런데 실제로 사각형은 몇 개의 점으로 구성되어 있는가?<br>

![인풋어셈블리1](https://user-images.githubusercontent.com/43705434/120767496-327f6080-c556-11eb-8d8f-50b69e386e14.PNG)<br>
<br>

위 그림과 같이 4개의 점으로 구성되어 있다.<br>
6개의 정점으로 사각형을 표현한다면 **2개의 점이 중복되어 메모리 낭비** 가 된다고 할 수 있다.<br>
만약 사각형 하나가 아니라 사각형 10,000개로 구성된 모델이라고 가정하면 20000개의 정점이 낭비되는 것이고 이것은 **엄청낭 손해**이다.<br>
또한 단순한 메모리의 낭비일 뿐만 아니라 **같은 정점에 대한 작업을 GPU에서 여러번 처리해야 하기 때문에 불필요한 계산량**까지 늘어난다.<br>
이러한 중복되는 정점을 **해결하기 위한 방법**이 바로 Index Buffer이다.<br>
위의 사각형의 예를 들면 정점 버퍼는 Vertex Bufer[] = { P0,P1,P2,P3} 이렇게 4개의 데이터만 갖고, 인덱스 버퍼를 추가로 생성하여<br>
Index Buffer[] = {0,1,2,1,3,2,} 이런식으로 **정점을 어떤 순서로 그려야 하는지 알려주는 목록**을 제공하면<br>
위에서 설명한 두 가지 문제를 해결할 수 있다. 인덱스 버퍼를 생성하는데에도 메모리가 드는데 이것은 낭비가 아니냐고 생각 할 수도 있겠지만<br>
인덱스버퍼는 그냥 정수이기 때문에 위치,색깔,법선,UV등등의 많은 데이터를 갖는 정점 구조체보다 훨씬 메모리를 적게 차지하기 때문에<br>
별 문제가 되지 않는데다가 중복되는 정점에 대해서 중복된 GPU 계산을 하지 않는다는 메리트가 굉장히 크기 때문에<br>
인덱스 버퍼에 소요되는 메모리는 걱정하지 않아도 된다.<br>
<br>

▶ 즉 인덱스버퍼는 정점을 어떤 순서로 그려야 하는지 알려주는 목록으로, 이를 제공함으로써 정점의 중복으로 인해 발생되는 여러 피해를 방지.<br> 
<br>
<br>
