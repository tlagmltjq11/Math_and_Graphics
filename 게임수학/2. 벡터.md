## 벡터<br>
<img src="https://user-images.githubusercontent.com/43705434/108397929-d4a36300-725b-11eb-89ca-a6cbd1d5c637.jpg" width="500" height="300">
<br>

**개념**<br>
보통 교과서에는 벡터를 **'크기와 방향을 가진 양을 수학적으로 표현한 것'** 으로 정의하고, 크기만 갖고 방향은 없는 양을<br>
스칼라라고 정의한다. 

**간단한 해석**<br>
벡터는 화살표라 생각하면 좋다.<br>
화살표는 길이와 방향을 갖는데, 여기서 길이가 속도나 위치로 해석될 수 있다. <2차원 벡터를 예로 설명><br>
-> Unity에서 사용하는 Transform 역시 3차원 벡터의 개념이다.<br>
<br>

## 위치벡터<br>
![위치벡터](https://user-images.githubusercontent.com/43705434/118966842-f9b38900-b9a4-11eb-97ea-59ecf61b6682.PNG)<br>
위치벡터는 **위치는 다르지만 방향과 크기가 같은 무수히 많은 벡터들의 대표 벡터** 이며, 간단히 점(좌표) 하나로 나타낼 수 있다.<br>
더 나아가 위치벡터의 종점을 이용하면 좌표평면 위 점의 성질을 그대로 만족하기 때문에 간단한 대수적 연산을 통해서 벡터의 연산이 가능해진다.
즉 흩어져 있는 벡터들은 서로 연산을 하기도, 평행여부를 확인하기도 어렵기 때문에 모든 벡터를 평행이동하여 <br>
벡터의 처음 점(시점)을 한 점으로 같게 하여 즉 위치벡터로 나타내어 쉽게 연산을 진행하면 된다.<br>
<br>

## 벡터의 선형결합, 생성, 선형종속, 선형독립과 기저벡터<br>
![선형결합](https://user-images.githubusercontent.com/43705434/118968382-d2f65200-b9a6-11eb-8abd-3fd6d26efcd5.PNG)<br>
벡터의 선형결합 = 두 벡터를 스케일하고 더하여 새 벡터를 얻는 것<br>
<br>

![생성](https://user-images.githubusercontent.com/43705434/118968385-d4277f00-b9a6-11eb-90c3-0a728efd12fb.PNG)<br>
벡터 v,w의 생성 = 모든 선형결합의 집합<br>
<br>
대부분의 2차원 벡터 쌍을 이용해서 2차원공간의 벡터 전체를 표현할 수 있지만,<br>
만약 2차원 벡터 쌍이 겹쳐있는 모양이거나 둘 다 영벡터라면 그렇지 못할 것이다.<br>
<br>

![선형종속](https://user-images.githubusercontent.com/43705434/118968388-d4c01580-b9a6-11eb-8a60-12067099aae0.PNG)<br>
세번째 벡터가 다른 두 벡터의 선형생성에 놓여있다면, 여전히 똑같은 평면에 갇혀있을 것이다.<br>
하지만 만약 두 벡터의 생성위에 놓여있지 않다면, **별개의 방향** 을 가리키는것이기 때문에<br>
모든 가능한 3차원 벡터에 접근할 수 있게 되는 것이다.<br>
이렇게 다른 두 벡터의 생성에 놓여있어, 해당 벡터를 제거해도 생성에 전혀 영향을 미치치않는 즉<br>
새로운 차원을 생성해내지 못하는 벡터를 선형종속 관계에 있다고 말한다.<br>
쉽게 표현하면 **벡터 중 하나가 다른 벡터들의 선형결합으로 표현될 수 있다** 는 것이다.<br>
이러한 벡터는 기저에 속할 수 없기에 기저벡터가 될 수 없다.<br>
<br>

![선형독립](https://user-images.githubusercontent.com/43705434/118968391-d4c01580-b9a6-11eb-83e0-170a3dbb3fd0.PNG)<br>
반대로 모든 벡터가 각자 **생성에 다른 차원을 구성** 한다면 그들은 선형독립적인 관계라고 말할 수 있다.<br>
-> 다른 두 벡터의 선형결합으로 표현될 수 없는 벡터<br>
<br>

![기저란](https://user-images.githubusercontent.com/43705434/118968392-d558ac00-b9a6-11eb-8c9d-5f09df127601.PNG)<br>
**기저란 공간을 생성하는 선형독립인 벡터의 집합을 의미한다!!** <br>
<br>

**기저벡터 : 벡터 공간에서 각각의 축방향을 가리키는 단위 벡터**<br>
<br>

## 벡터의 연산<br>

> 같은 차원의 벡터끼리만 계산이 가능하다. !!
<br>

**벡터의 덧셈**<br>
단순히 각 요소들을 더해주면 된다.<br>
a벡터 + b벡터 = (a.x + b.x, a.y + b.y) <br>

평행사변형을 만들고 가로지르는것을 상상하면 쉽다.<br>
<img src="https://user-images.githubusercontent.com/43705434/108397932-d5d49000-725b-11eb-8b12-d3ff622bd147.png" width="500" height="300">
<br>

또 다른 관점에서 살펴보면 두 벡터의 합은 서로 다른 방향의 두 힘이 충돌했을 때의<br> 
그 합쳐진 힘의 진행 방향으로 해석될 수도 있다<br>
<img src="https://user-images.githubusercontent.com/43705434/108397935-d66d2680-725b-11eb-9298-0d7fdcef45ee.png" width="500" height="300">
<br>
<br>
<br>

**벡터의 뺄셈**<br>
a벡터 - b벡터 = (a.x - b.x, a.y - b.y)<br>
a벡터 + -b벡터<br>
<img src="https://user-images.githubusercontent.com/43705434/108397936-d705bd00-725b-11eb-9d11-c19fc881dd10.png" width="500" height="300">
<br>

**벡터 스칼라곱셈**<br>
a벡터 x 3 = (a.x * 3, a.y * 3)<br>

> 벡터간 나눗셈이란 개념은 없고 곱셈은 내적, 외적 2가지로 설명할 수 있다. (추후 설명)
<br>

**벡터의 길이**<br>
(x, y) 2차원 벡터를 화살표로 표현했을때 이 화살표의 길이는 피타고라스의 정리를 이용해서 구할 수 있다.<br>
이러한 벡터의 길이를 ||V|| 로 표현한다.<br>
Vector3 a;<br>
a.magnitude(); // 벡터의 길이를 반환<br>
<br>

**벡터의 단위화**<br>
Normalize(단위화)란 벡터의 길이를 1로 만들어서 순수히 방향만 나타내게끔 하는 것이다.<br>
V / ||V|| 의 과정을 통해서 진행된다. => (x / ||V||, y / ||V||) 길이가 1이 되는 단위벡터가 됨.<br>
Vector3 a;<br>
a.normalize(); // 단위벡터를 반환<br>


//타겟위치로 프레임마다 이동시키는 코드<br>

```c#
void Update()
{
	Move();
}

void Move()
{
	Vector3 dir = target.position - gameObejct.transform.position; //각 벡터를 원점에서 뻗어나오는 화살표라고 생각할때
	//-> (벡터의 뺄셈 그림 참조) target.position + -gameObejct.transform.position 로 설명할 수 있으므로
	//위와 같이 현재위치에서 타겟까지의 방향과 거리를 가진 벡터를 추출할 수 있다.
	dir.Normalzie(); //단위벡터로 만들어 방향만을 추출
	dir *= speed * Time.deltaTime; //speed * Time.deltaTime을 통해 1프레임 동안 이동할 거리를 결정
	gameObejct.transform.position += dir; //이동
}
```
<br>

## 벡터와 좌표<br>
벡터의 표현법과 좌표의 표현법이 같다는 것은 이미 눈치를 채고 있을 것이다. <br>
다시 말하면 (3, 1)은 2차원 벡터를 뜻하기도 하지만, 좌표평면위의 한 점 을 뜻한다. <br>
또한 (1, 4, 3)은 3차원 벡터를 뜻하기도 하지만, 공간좌표에서의 한 점 을 뜻하기도 한다. <br>
<br>
![3차원 좌표](https://user-images.githubusercontent.com/43705434/108397938-d705bd00-725b-11eb-9494-c212cef9b673.png)

> 해당 3차원 벡터를 통해 유니티에서 좌표계를 나타낼 수 있다.<br>
<br>
<br>

## 벡터의 내적<br>
내적은 벡터간의 곱셈으로 스칼라곱 또는 Dot Product 라고도 하며, 기호로 · (Dot)을 쓴다.<br>
벡터의 내적을 구하는 방식은 두가지가 존재한다.<br>

1. 좌표값의 각 성분을 곱해서 더하는 방식<br>
A·B = (Ax * Bx) + (Ay * By) + (Az * Bz)
<br>

2. 벡터의 크기를 곱하는 방식 (좀 더 비싼 방식)<br>
A·B = ｜A｜x｜B｜x cosΘ<br>
사실 2번째 방식은 코사인법칙을 전개하게되면 1번째 방식으로 변경된다.<br>
<br>

![코사인법칙](https://user-images.githubusercontent.com/43705434/119385214-cb191380-bd00-11eb-8ccf-fafc351e3b2c.PNG)<br>
<br>
<br>

![정사영](https://user-images.githubusercontent.com/43705434/119222023-475afd80-bb2d-11eb-963a-5c244edc5cbb.PNG)<br>
벡터의 내적은 벡터간의 투영 길이를 나타내는 의미<br>
또한, 두 벡터간의 각도를 얻을 수 있는 방법을 의미하기도 한다.<br>
<br>

### 내적을 이용해 두 벡터사이의 각도를 구하는 방법<br>
A·B = ｜A｜x｜B｜x cosΘ 해당 식에서 ｜A｜x｜B｜로 양변을 나눠준 후 arccos을 취해주게되면<br>
Θ = arccos(A·B / ｜A｜x｜B｜)가 되기 때문에 세타 즉 각도를 구할 수 있게 된다.<br>
<br>
<br>

**tip. 내적을 이용해 점과 평면사이의 거리 구하기**<br>
![내적을이용한점과평면사이의거리](https://user-images.githubusercontent.com/43705434/119221760-c64f3680-bb2b-11eb-9482-cb909e8eff60.PNG)<br>
<br>

평면위 임의의 점을 선택하고 거리를 구해야 할 공간상의 점을 벡터의 차를 통해 두 점을 잇는 벡터를 구한다.<br>
그 후 해당 벡터를 내적을통해 법선벡터에 정사영시키면 해당 길이가 점과 평면사이의 거리가 된다.<br>
<br>
<br>

**tip. 내적을 이용한 백어택 판별**<br>
![내적코사인값](https://user-images.githubusercontent.com/43705434/109042284-5d664700-7713-11eb-8dcb-529ee431cb34.PNG)<br>
A·B = ｜A｜x｜B｜x cosΘ 공식에서 만약 A,B벡터의 길이가 1이라면 cosΘ값에 의해서 결과가 결정될 것이다.<br>
이때 두 벡터가 같은 방향을 바라보고 있다면 세타값이 0이므로 cos0 = 1 값이 나오며<br>
두 벡터가 서로 반대되는 방향을 바라보고 있다면 세타값이 180이므로 cos180 = -1값이 나온다.<br>
또한 두 벡터가 직교한다면 세타값이 90이므로 cos90 = 0값이 나오게된다.<br>
이러한 성질을 이용해보자. 두 벡터를 노말라이즈 한 후 내적연산을 진행하게되면 -1 ~ 0 ~ 1 사이의 값이 나오게 될 것이다.<br>
이 값을 통해서 두 벡터가 같은 방향을 바라보고 있는지, 직교하는지, 마주보고있는지를 판별할 수 있게된다.<br>
예를들자면, 총알의 진행방향(벡터)과 적 오브젝트의 전방방향(벡터)을 내적연산하여 0보다 큰 값이라면 백어택 처리를 해줄 수 있다.<br> 
<br>
<br>

**tip. 내적을 이용한 시야각 구현**<br>
![내적시야각](https://user-images.githubusercontent.com/43705434/109106848-f75ddc00-7773-11eb-87a7-5ab184dd1f60.PNG)<br>
플레이어의 정면을 기준으로 90도 내에 적이 들어올 시 감지하는 기능을 만든다고 가정해보자.<br>
(정면기준 왼쪽 45도 오른쪽 45도 내에 적이 들어와야 할 것이다.)<br>
우선 플레이어가 바라보는 시선벡터와 적과 플레이어의 차이로 나오는 벡터 A 간의 내적을 통해서<br>
코사인값을 얻어낼 수 있을 것이다. (벡터는 노말라이즈) 이때 플레이어의 정면이 시초선이기 때문에,<br>
각도가 정면과 가까워 질수록 코사인값은 1에 가까워져야한다. 그렇기 때문에 벡터 A와의 내적을 통해 얻어낸<br> 
코사인값이 (시야각 / 2) 코사인값보다 크다면 적이 시야각내에 들어와있는 것으로 판단할 수 있다.<br>
<br>
<br>

**tip. 내적을 이용한 앞뒤 구분**<br>
![내적앞뒤구분](https://user-images.githubusercontent.com/43705434/109106844-f62caf00-7773-11eb-89c3-2e10090c240a.PNG)<br>
적이 플레이어의 앞에 존재하는지, 뒤에 존재하는지 판별하는 기능을 만든다고 가정해보자.<br>
플레이어의 정면벡터 즉 forward벡터를 기준으로 좌, 우 90도까지는 적 벡터와의 사잇각을 통해 코사인을 계산하면<br>
무조건 양수값이 나오기 때문에 해당 값을 통해 앞에 존재하는 것을 파악할 수 있다. 하지만 좌우로 90도가 넘어가서<br>
사잇각이 둔각이 된다면 코사인은 무조건 음수값이 나오게 되므로 해당 값을 통해 뒤에 존재한다는 것을 파악할 수 있다.<br>
<br>
<br>

**tip. 내적을 이용한 뒷면 렌더링 제외하기**<br>
![내적렌더링제외](https://user-images.githubusercontent.com/43705434/119091767-84998f80-ba48-11eb-8e5d-37164758dcbe.PNG)<br>
위 그림은 정육면체를 3D 그래픽으로 렌더링 한 모습이다.<br>
왼쪽 그림을 보면 정육면체의 면들 중 단 두 개의 면만 화면에 렌더링 되고 있는 것을 알 수 있다.<br>
<br>

검은색으로 그려진 선은 각 폴리곤으로부터 카메라쪽으로 향하는 벡터를 나타낸 것이며 파란색 화살표는 법선벡터이다.<br>
그림으로 봤을 때 이 두 벡터 사이의 각도가 90도 이하면 해당 폴리곤은 카메라쪽을 바라보고 있다고 판단할 수 있다. (a, b)<br>
<br>

반대로 각도가 90도 보다 크면 카메라를 등지고 있다고 판단할 수 있다. (c, d)<br>
카메라를 등지고 있는 폴리곤은 어차피 보이지 않을 것이므로 계산에서 제외한다면 렌더링 성능이 훨씬 올라갈 것이다.<br>
<br>

https://www.youtube.com/watch?v=sjTvDGfER0w&list=PL-xqYJ8bjgMC-p94R7iXjFCs-znRg93PJ&index=15<br>
**위와 비슷하지만 내적을 이용한 라이팅 관련 처리**<br>
<br>

**tip. 내적을 이용한 반사벡터 구하기**<br>
내적을 이용하면 반사벡터도 쉽게 구할 수 있다.<br>
벽에 부딪힌 당구공이 어느 방향으로 튕겨 나가는지 상상해 본다면 반사벡터의 모습이 머릿속으로 그려질 것이다.<br>
<br>

이러한 반사벡터는 다음과 같이 구할 수 있다. (velocity가 공의 속도벡터)<br>
> Vector3 reflect = velocity + 2 * normal * Vector3.Dot(-velocity, normal);<br>
<br>

이 공식이 어떻게 유도되는지 살펴보자.<br>
![반사벡터1](https://user-images.githubusercontent.com/43705434/119091757-82373580-ba48-11eb-8779-e8667386b670.PNG)<br>
![반사벡터2](https://user-images.githubusercontent.com/43705434/119091760-83686280-ba48-11eb-83ff-8e4e3050325a.PNG)<br>
![반사벡터3](https://user-images.githubusercontent.com/43705434/119091761-83686280-ba48-11eb-85a1-a2dd8be52a98.PNG)<br>
![반사벡터4](https://user-images.githubusercontent.com/43705434/119091762-8400f900-ba48-11eb-83ce-9648efcb9779.PNG)<br>
![반사벡터5](https://user-images.githubusercontent.com/43705434/119091766-8400f900-ba48-11eb-8562-21b4baa4563b.PNG)<br>
<br>

여기서 이해해야 할 부분은 벡터의 내적을 통해서 한 벡터가 다른 벡터에 투영된 길이를 알 수 있다는 것이다.<br>
반사벡터를 구할 때 벡터 -p를 벽의 법선 벡터인 n과 내적 하여 계산했는데,<br>
이 내적의 결과로 나온 값은 벡터 -p를 법선 벡터 n에 투영한 길이가 된다.<br>
(단, 법선 벡터 n은 반드시 단위 벡터 상태로 되어 있어야 한다.)<br>
<br>

**2를 곱해주는 이유?**<br>
위 수식을 풀어보면, 2 * n * (-p∙n) 이다.<br>
n * (-p∙n) 만 먼저 계산해 보면 (-p∙n) = 스칼라값이고 여기에 n을 곱하면 벡터 n의 길이는<br> 
위 그림에서 벡터 -p의 높이성분과 같은 길이를 갖게 된다.<br>
여기에 2를 곱하면 길이가 두배로 늘어난 벡터가 된다.<br> 
이걸 벡터 p와 더해주면 입사각과 똑같은 크기를 가진 반사벡터가 생기게 된다.<br>
<br>

만약 2를 곱하지 않는다면?<br>
벡터 n의 길이는 벡터 -p를 n에 투영한 만큼의 길이를 갖게 되므로(마지막 그림에서 점선 부분)<br>
최종적으로 구해지는 반사벡터는 벽면에 평행한 벡터가 되기 때문에 원하는 반사벡터를 구할 수 없게 된다.<br>

**★대신 2를 곱하지 않는다면 슬라이딩 벡터를 구할 수 있을 것이다. 즉 벽에 부딪힌 후 미끄러질때의 방향을 구할 수 있는 것이다.★**<br>
<br>
<br>

## 벡터의 외적<br>
![외적좌표계](https://user-images.githubusercontent.com/43705434/109163803-12a10980-77bd-11eb-945e-2c431a428c28.PNG)<br>
<br>
내적을 기하학적인 의미로 봤을 때, 두 벡터가 이루는 각이라면, 외적은 기하학적으로 볼때<br>
두 벡터 모두에게 수직인 벡터를 의미한다.<br>

이러한 또다른 벡터의 곱셈인 외적은 Cross Product라고도 하며, 기호로 X (Cross)를 사용한다.<br>
또한 내적은 2차원, 3차원에서 사용될 수 있으나, 외적은 3차원 이상에서만 의미를 가진다.<br>
그 이유는 내적은 결과값으로 스칼라를 반환하지만, 외적은 두 벡터와 직교하는 벡터를 반환하기 때문이다.<br>
<br>
공식1<br>
![외적공식1](https://user-images.githubusercontent.com/43705434/109163807-146acd00-77bd-11eb-8d71-a07e5983c37b.PNG)<br>
<br>

공식2<br>
**정확히는 외적의 결과 벡터의 길이를 나타내는 공식임<br>
-> 그렇기에 스칼라로 나오는것이며 해당 스칼라값은 A, B 벡터가 이루는 평행사변형의 넓이와 같다.**<br>

![외적공식2](https://user-images.githubusercontent.com/43705434/109163818-159bfa00-77bd-11eb-840d-ca6b6bf5f5bc.PNG)<br>
<br>
<br>

**외적의 특징**<br>
1. 외적한 결과값과 A, B중 하나와 내적을하게되면 직교하므로 0값이 나오게 된다.<br>
2. 벡터의 내적 같은 경우 교환법칙이 성립하지만, 외적은 곱하는 순서가 중요하다.<br>
3. 외적의 결과값으로 나온 벡터 C의 크기는 A와 B를 연결한 평행사변형의 넓이와 같다.<br>
4. 외적도 내적과 마찬가지로 주로 단위벡터와 함께 사용하는데, 이때 외적값인 벡터 C의 크기로 A와 B의 사이각을 판단할 수 있다.<br>
-> 벡터 C의 크기가 1이라면 A와 B를 연결해서 만든 도형이 가로세로 1인 정사각형임. 고로 A,B는 수직<br>
-> 벡터 C의 크기가 0이라면 두 벡터가 일치하거나 방향이 반대임을 알 수 있다.<br>
<br>
<br>

**tip. 외적을 통한 평행사변형의 넓이**<br>
![외적공식](https://user-images.githubusercontent.com/43705434/119097458-b6622480-ba4f-11eb-982b-849879925721.PNG)<br>
<br>

![평행사변형외적](https://user-images.githubusercontent.com/43705434/119097463-b6fabb00-ba4f-11eb-889b-7119e44a6837.PNG)<br>
<br>

높이는 벡터 a와 b가 이루는 각도를 삼각함수 사인(sin)으로 계산한 값에 a의 길이를 곱한 것과 같다.<br>
결국 높이 = |a|∙sinθ 가 되며, 밑변 = b의 길이 이므로 밑변(|b|) ˟ 높이(|a|∙sinθ)를 통해서<br> 
두 벡터 a와 b가 만드는 평행사변형의 넓이를 구할 수 있는 것이다.<br>
<br>

이 공식은 벡터의 외적을 구하는 공식 |a|∙|b|∙sinθ∙n에서 벡터 n만 제외한 것과 같다.<br>
결국 **외적으로 구해진 벡터의 길이는 평행사변형의 넓이와 같다** 는 것을 알 수 있다.<br>
<br>
<br>

**tip. 외적을 이용한 법선벡터(평면에 수직인 벡터)  구하기**<br>
![외적법선벡터](https://user-images.githubusercontent.com/43705434/109163822-16cd2700-77bd-11eb-977f-19f50c4a0da5.PNG)<br>
<br>
이러한 외적은 법선벡터를 구하는데 사용될 수 있는데, 예를들어 삼각형의 세 점을 알고 있다면<br>
차를 통해 벡터 2개를 구할 수 있게 되고 그 두 벡터를 외적하면 해당 평면의 법선 벡터를 구할 수 있다.<br>
-> 이는 두 벡터와 직교하는 외적값의 성질을 이용한 것이다.<br>
<br>
<br>

**tip. 외적을 이용한 점과 직선사이의 거리 구하기**<br>
![외적평행사변형](https://user-images.githubusercontent.com/43705434/109163834-19c81780-77bd-11eb-9798-7709dc2f8105.PNG)<br>
<br>

![외적점과직선사이거리](https://user-images.githubusercontent.com/43705434/109163825-17fe5400-77bd-11eb-9a46-a33e7e8ca6aa.PNG)<br>
<br>

위에서 외적의 결과는 두 벡터를 연결한 평행사변형의 넓이와 같다고 설명한것을 볼 수 있다<br>
이를 이용해서 점과 직선사이의 거리를 구할 수 있다. 위 그림을 참고해보자면 S직선과 A라는 점이 있을때<br>
A와 S사이의 거리를 구하고 싶다면 BC벡터와 BA벡터를 구해 두 벡터의 외적을 계산한다.<br>
그렇게되면 그림에 나오는 것처럼 평행사변형의 넓이를 구하게 되는 꼴인데, 이때 BC로 나눠주게되면<br>
평행사변형의 넓이 = 밑변 X 높이 이므로 즉 밑변으로 양변을 나눠준 꼴이 되기 때문에<br> 
결과값인 ｜BA｜sinΘ는 높이가 되게 된다. 해당 높이는 점과 직선사이의 거리와 같다.<br>

> 이를 응용해보자면 레이저를 쐈을때 레이저와 가장 가까운 적을 구해낼 수 있을 것이다.<br>
<br>
<br>

**tip. 외적을 이용한 좌,우 구별하기**<br>
![내적외적코드](https://user-images.githubusercontent.com/43705434/109163830-1896ea80-77bd-11eb-95e2-22bf38715530.PNG)<br>
(위 코드는 외적의 결과로 나온 벡터의 y축 값을 통해서 좌우를 구별)<br>
<br>
<br>

**(아래 설명은 아직 완전하지 못함. 이해한대로만 설명한 부분이기 때문에 추후에 대폭 수정될 부분들임 고로 밑에 설명 참고)**<br>
플레이어의 정면벡터 A와 목표물의 위치벡터와 플레이어 벡터의 차를 통해 구해낸 목표물까지의 벡터 B를<br>
노말라이즈 한 후 외적하게되면 ｜A｜x｜B｜x sinΘ 공식에의해 sinΘ 값 즉 두 벡터의 사잇각에 따른 사인값이<br>
최종결과가 되게 된다. 플레이어의 정면벡터를 시초선으로 하기 때문에 사인함수의 특성상 -180도 ~ 0도는 음수값<br>
0도 ~ 180도 까지는 양수값을 가지게 된다. 고로 목표물이 오른쪽에 있으면 양수값, 왼쪽에 있으면 음수값을<br>
반환하게 된다. 고로 외적의 결과를 통해서 목표물이 플레이어 기준 왼쪽에 위치하는지 오른쪽에 위치하는지<br>
알아낼 수 있게 된다.<br>

**★위 설명은 완전하지 못하기에 블로그를 참고하여 설명할 것임.★**<br>
우선 유니티는 왼손좌표계를 사용하기 때문에, 일반 수학과는 반대로 생각해야한다.<br>
우선 플레이어의 정면벡터가, 즉 앞벡터 A가 기준벡터가 되어야 할 것이다.<br>
그 후, 목표물까지의 벡터 즉 플레이어에서 목표물까지의 방향벡터 B를 구한다.<br>
A X B 즉 외적을 계산해준다. 이때 B가 오른쪽에 위치한다면 왼손좌표계에 의해서 말아쥐어줘야하는<br>
방향이 오른쪽이기 때문에 엄지는 위를 향한다. 즉 외적의 결과 벡터의 Y값은 양수이다.<br>
만약 B가 왼쪽에 위치한다면 왼손좌표계에 의해서 말아쥐어야하는 방향은 왼쪽이기 때문에 엄지는 아래를 향한다.<br>
즉 외적의 결과 벡터의 Y값은 음수라는 것이다. 이를 통해서 외적의 결과 벡터의 Y값이 음수냐 양수냐에 따라<br>
목표물이 플레이어 기준 왼쪽에 위치하는지 오른쪽에 위치하는지 알아낼 수 있다.<br>
<br>
<br>

## 내적과 외적을 이용한 점과 직선,평면 사이의 거리 구하기
**점과 직선사이의 거리는 내적, 외적 두가지 방법으로 모두 구할 수 있다.**<br>
-> 내적 : 직선 위 임의의 점으로 부터 거리를 구해야 할 점까지의 벡터를 구하고 해당 벡터를 직선과 수직인 법선벡터로 정사영시킨 길이를 구한다.<br>

-> 외적 : 직선 위 임의의 벡터를 선택하고, 시작점을 동일하게 두고 거리를 구해야 할 점까지의 벡터를 구한다. 두 벡터를 외적시키면<br>
평행사변형의 넓이가 나오기 때문에 해당 넓이에 첫번째 직선을 나누어 높이 즉 점과 직선사이의 거리를 구한다.<br>
<br>

**점과 평면사이의 거리는 내적, 외적 두가지 방법으로 모두 구할 수 있다.**<br>
-> 내적 : 평면의 법선벡터를 구한 후 평면 위 임의의 점으로부터 거리를 구해야 할 점까지의 벡터를 구한다. <br>
그 후 두 벡터를 내적하면 법선벡터는 단위벡터이기에 정사영의 길이가 나온다. 해당 길이가 곧 점과 평면사이의 최단거리이다.<br>

-> 외적 : 평면 위 임의의 벡터를 선택한다. 첫번째 벡터와 시작점이 같은, 거리를 구해야 할 점까지의 벡터를 구한다. 두 벡터를 외적한다.<br>
해당 외적 값은 첫번째벡터크기 x 두번째벡터크기 x sin세타 이기 때문에 첫번째 벡터로 나누어주면 삼각함수에(빗변 x sin세타 = 높이) 의해<br>
점과 평면 사이의 거리가 구해진다.<br>
**(이때 두 벡터가 만들어내는 평행사변형이 주어진 평면과 수직을 이루어야만 가능하다.)**<br>
<br>
<br>
