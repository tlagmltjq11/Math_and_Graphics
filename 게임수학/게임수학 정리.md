## 피타고라스의 정리<br>
상식(?)이므로 굳이 정리를 설명하진 않겠다.
<br>

![피타고라스](https://user-images.githubusercontent.com/43705434/108397930-d5d49000-725b-11eb-857e-d866645d6d2e.png)
<br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;				b(100, 80)<br>
<br>
<br>
a(20, 20)
<br>
<br>

**_EX)_**<br>
a에서 b까지 오브젝트가 이동해야 할때 **iTween.MoveTo(obj, Destination, time);** 을 자주 사용한다고 한다.<br>
이때 time 값을 어떻게 구할 것인가?<br>
<오브젝트는 40/sec로 일정하게 이동한다.><br>

이런 경우에 피타고라스의 정리를 이용해서 a와 b 사이의 거리를 구하고 해당 거리를 40/sec 로 나누어주면<br>
적절한 time 값을 구할 수 있을 것이다.<br>
<br>

a와 b 사이의 거리를 c라고 할때 피타고라스 정리에 의해 **c = √(60² + 80²)** 가 성립되며 **c = √10000 = 100**이 된다.<br>
고로 적절한 time 값은 **100 / 40 = 2.5**초라는 것을 알아낼 수 있다.<br>

Unity에서는 피타고라스를 이용하는 **Vector3.Distance** 함수를 이용해서 간단한게 오브젝트간의 거리를 구할 수 있다.<br>
(두 벡터의 차를 구한 후 해당 벡터의 길이를 구함)<br>
<br>


## 선형대수학<br>
선형대수학이란 쉽게 말해 "선형성"이라는 성질을 갖는 대상들을 연구하는 수학의 분야라고 할 수 있다.<br> 
여기서 선형이라는 의미는 x^2 이나 x^3이 아닌 2x, 3x 처럼 직선(원점을지나는)을 이루는 것을 의미한다.<br>

**<선형에 대한 증명>**<br>
함수 와 임의의 수 에 대해 아래와 같은 식이 성립할 때 함수 는 선형이라고 한다.<br>
> 조건 1: f(x+y) = f(x) + f(y);<br>
> 조건 2: f(ax) = af(x);
<br>

예)<br>
f(x) = 5x<br>
g(x) = 2x²<br>
h(x) = 2x + 4<br>

f(x+y) = 5x + 5y = f(x) + f(y)<br>
f(ax) = 5ax = af(x)<br>
위 조건을 만족하므로 선형<br>

g(x+y) = 2(x+y)² = 2x² + 4xy + 2y²<br>
g(ax) = 2(ax)² = 2a²x²<br>
위 조건을 만족하지 못함.<br>

h(x+y) = 2(x+y) + 4 = 2x + 2y + 4<br>
h(x) + h(y) = 2x + 4 + 2y + 4 = 2x + 2y + 8<br>

h(ax) = 2ax + 4<br>
ah(x) = a(2x + 4) = 2ax + 4a<br>
위 조건을 만족하지 못함.<br>

즉, 다항함수에 대해서는 이차함수 이상의 고차함수는 선형성을 가질 수 없으며<br>
일차함수의 경우에도 원점을 지날 경우에만(y절편이 0일 경우에만) 선형성을 가짐을 알 수 있다.<br>

**정리하자면 선형대수학은 "선형성"을 갖는 대상들을 연구하는 수학의 분야이고, 공대 학부생들은 그 중에서도 가장 기초적인<br>
벡터와 행렬과 관련된 다양한 내용들(선형방정식, 기저, 벡터 공간, 행렬의 고윳값과 고유벡터, 행렬식 등등)을 중점적으로 공부하게 된다.**<br>
<br>

## 벡터와 행렬이 등장하는 이유<br>
1. 벡터<br>

**선형시스템은 1차연립방정식**을 의미한다고 할 수 있는데, 다음과같은 2원 1차연립방정식을 풀어낸다는 것은<br>
각 방정식을 기하적으로 바라볼때 두 직선을 의미하기 때문에 **결과적으로 두 직선의 교점인 위치벡터를 구하는 것**이라고<br>
풀이할 수 있다. 결국 선형시스템을 기하적으로 해석하면 **벡터**를 자연스레 만나게 되기 때문이다.<br> 
![2원1차연립방정식](https://user-images.githubusercontent.com/43705434/118966340-9a557900-b9a4-11eb-9c71-dc2a99a91cf7.PNG)<br>
<br>

2. 행렬<br>

이번에는 또다른 기학적 관점을 적용해보자, 위 방정식을 아래와 같이 변형한다.<br>
이 행렬을 전개해보면 위 방정식과 일치한다는 것을 알 수 있다.<br>
**기하적으로 해석해보면, (x1, x2)라는 벡터에 어떤 행렬을 곱했더니 (3,1)이라는 벡터가 나왔다.<br>
라고 해석**할 수 있다. **즉 행렬이 벡터를 '변환'시키는 역할**을 한 것이다.<br>
![2원1차 행렬표기](https://user-images.githubusercontent.com/43705434/118966344-9b86a600-b9a4-11eb-8aad-f8e411b8c596.PNG)<br>
<br>

이러한 행렬의 일차 선형변환을 통해서 모든 벡터를 다른 벡터로 대응시키는 **좌표계 자체의<br>
변환(기저벡터의 변환)** 을 이루어낼 수 있다. (**역행렬** - 원래대로 되돌리는 역선형변환)<br>
고로 2원 1차선형시스템을 풀어낸다는 것은 두 직선의 교점의 위치벡터를 구한다고 이해할 수도 있고,<br>
어떤 행렬을 곱한 변환의 결과가 (3,1)이 되는 벡터 (x1, x2)를 찾는 과정이라고 말할 수도 있는 것이다.<br>
이러한 개념은 미지수가 n개인 **n차평면** 으로 까지 확장될 수 있다.<br>
<br>
<br>

## 벡터<br>
<img src="https://user-images.githubusercontent.com/43705434/108397929-d4a36300-725b-11eb-89ca-a6cbd1d5c637.jpg" width="500" height="300">
<br>

**개념**<br>
보통 교과서에는 벡터를 **'크기와 방향을 가진 양을 수학적으로 표현한 것'** 으로 정의하고, 크기만 갖고 방향은 없는 양을<br>
스칼라라고 정의한다. 

**간단한 해석**<br>
벡터는 화살표라 생각하면 좋다.<br>
화살표는 길이와 방향을 갖는데, 여기서 길이가 속도나 위치로 해석될 수 있다. <2차원 벡터를 예로 설명><br>
-> Unity에서 사용하는 Transform 역시 3차원 벡터의 개념이다.<br>
<br>

## 위치벡터<br>
![위치벡터](https://user-images.githubusercontent.com/43705434/118966842-f9b38900-b9a4-11eb-97ea-59ecf61b6682.PNG)<br>
위치벡터는 **위치는 다르지만 방향과 크기가 같은 무수히 많은 벡터들의 대표 벡터** 이며, 간단히 점(좌표) 하나로 나타낼 수 있다.<br>
더 나아가 위치벡터의 종점을 이용하면 좌표평면 위 점의 성질을 그대로 만족하기 때문에 간단한 대수적 연산을 통해서 벡터의 연산이 가능해진다.<br>
<br>

## 고유값과 고유벡터<br>
어떤 벡터들은 선형변환 시 크기만 바뀌고 방향이 바뀌지 않을 수 있다.<br>
다시말해 입력벡터를 A로 선형변환 시킨 결과가 상수배라는 의미이다.<br>
![고유벡터](https://user-images.githubusercontent.com/43705434/118966346-9b86a600-b9a4-11eb-816c-57c30ad91e2e.PNG)<br>
<br>

**선형변환 A를 취했을때 그 크기만 변하고 방향은 변하지않는 벡터는 무엇인가?** -> 고유벡터<br>
그렇다면 크기는 얼마나 변했는가 ? -> 고유값<br>
![고유값과고유벡터그림](https://user-images.githubusercontent.com/43705434/118966349-9c1f3c80-b9a4-11eb-8bdf-47d15c32a7eb.PNG)<br>
<br>

## 행렬식의 기하학적 의미<br>
![행렬식의기하학적의미](https://user-images.githubusercontent.com/43705434/118966351-9c1f3c80-b9a4-11eb-8620-b4dcfc3d21a6.PNG)<br>
행렬식이 의미하는 것: 선형변환 될 때 **기저벡터가 이루는 단위 면적** 이 얼마만큼 늘어나는가이며 값이 면적 자체를 의미한다.<br>
-> 위 의미를 통해서 역행렬을 구할때 1/행렬식 을 곱해주는 이유를 추론할 수 있을 것이다.<br>
-> 역행렬은 원래대로 되돌리는 역-선형변환이기에 단위면적 또한 원래대로 돌이키기 위해서 1/행렬식을 곱해주는 것이다.<br>
(3x3 행렬식은 3차원에서 3 기저벡터가 이루는 평행육면체의 부피.)<br>
<br>

## 벡터의 선형결합, 생성, 선형종속, 선형독립과 기저벡터<br>
![선형결합](https://user-images.githubusercontent.com/43705434/118968382-d2f65200-b9a6-11eb-8abd-3fd6d26efcd5.PNG)<br>
벡터의 선형결합 = 두 벡터를 스케일하고 더하여 새 벡터를 얻는 것<br>
<br>

![생성](https://user-images.githubusercontent.com/43705434/118968385-d4277f00-b9a6-11eb-90c3-0a728efd12fb.PNG)<br>
벡터 v,w의 생성 = 모든 선형결합의 집합<br>
<br>
대부분의 2차원 벡터 쌍을 이용해서 2차원공간의 벡터 전체를 표현할 수 있지만,<br>
만약 2차원 벡터 쌍이 겹쳐있는 모양이거나 둘 다 영벡터라면 그렇지 못할 것이다.<br>
<br>

![선형종속](https://user-images.githubusercontent.com/43705434/118968388-d4c01580-b9a6-11eb-8a60-12067099aae0.PNG)<br>
세번째 벡터가 다른 두 벡터의 선형생성에 놓여있다면, 여전히 똑같은 평면에 갇혀있을 것이다.<br>
하지만 만약 두 벡터의 생성위에 놓여있지 않다면, **별개의 방향** 을 가리키는것이기 때문에<br>
모든 가능한 3차원 벡터에 접근할 수 있게 되는 것이다.<br>
이렇게 다른 두 벡터의 생성에 놓여있어, 해당 벡터를 제거해도 생성에 전혀 영향을 미치치않는 즉<br>
새로운 차원을 생성해내지 못하는 벡터를 선형종속 관계에 있다고 말한다.<br>
쉽게 표현하면 **벡터 중 하나가 다른 벡터들의 선형결합으로 표현될 수 있다** 는 것이다.<br>
이러한 벡터는 기저에 속할 수 없기에 기저벡터가 될 수 없다.<br>
<br>

![선형독립](https://user-images.githubusercontent.com/43705434/118968391-d4c01580-b9a6-11eb-83e0-170a3dbb3fd0.PNG)<br>
반대로 모든 벡터가 각자 **생성에 다른 차원을 구성** 한다면 그들은 선형독립적인 관계라고 말할 수 있다.<br>
-> 다른 두 벡터의 선형결합으로 표현될 수 없는 벡터<br>
<br>

![기저란](https://user-images.githubusercontent.com/43705434/118968392-d558ac00-b9a6-11eb-8c9d-5f09df127601.PNG)<br>
**기저란 공간을 생성하는 선형독립인 벡터의 집합을 의미한다!!** <br>
<br>
<br>

## 벡터의 연산<br>

> 같은 차원의 벡터끼리만 계산이 가능하다. !!
<br>

**벡터의 덧셈**<br>
단순히 각 요소들을 더해주면 된다.<br>
a벡터 + b벡터 = (a.x + b.x, a.y + b.y) <br>

평행사변형을 만들고 가로지르는것을 상상하면 쉽다.<br>
<img src="https://user-images.githubusercontent.com/43705434/108397932-d5d49000-725b-11eb-8b12-d3ff622bd147.png" width="500" height="300">
<br>

또 다른 관점에서 살펴보면 두 벡터의 합은 서로 다른 방향의 두 힘이 충돌했을 때의<br> 
그 합쳐진 힘의 진행 방향으로 해석될 수도 있다<br>
<img src="https://user-images.githubusercontent.com/43705434/108397935-d66d2680-725b-11eb-9298-0d7fdcef45ee.png" width="500" height="300">
<br>
<br>
<br>

**벡터의 뺄셈**<br>
a벡터 - b벡터 = (a.x - b.x, a.y - b.y)<br>
a벡터 + -b벡터<br>
<img src="https://user-images.githubusercontent.com/43705434/108397936-d705bd00-725b-11eb-9d11-c19fc881dd10.png" width="500" height="300">
<br>

**벡터 스칼라곱셈**<br>
a벡터 x 3 = (a.x * 3, a.y * 3)<br>

> 벡터간 나눗셈이란 개념은 없고 곱셈은 내적, 외적 2가지로 설명할 수 있다. (추후 설명)
<br>

**벡터의 길이**<br>
(x, y) 2차원 벡터를 화살표로 표현했을때 이 화살표의 길이는 피타고라스의 정리를 이용해서 구할 수 있다.<br>
이러한 벡터의 길이를 ||V|| 로 표현한다.<br>
Vector3 a;<br>
a.magnitude(); // 벡터의 길이를 반환<br>
<br>

**벡터의 단위화**<br>
Normalize(단위화)란 벡터의 길이를 1로 만들어서 순수히 방향만 나타내게끔 하는 것이다.<br>
V / ||V|| 의 과정을 통해서 진행된다. => (x / ||V||, y / ||V||) 길이가 1이 되는 단위벡터가 됨.<br>
Vector3 a;<br>
a.normalize(); // 단위벡터를 반환<br>


//타겟위치로 프레임마다 이동시키는 코드<br>

```c#
void Update()
{
	Move();
}

void Move()
{
	Vector3 dir = target.position - gameObejct.transform.position; //각 벡터를 원점에서 뻗어나오는 화살표라고 생각할때
	//-> (벡터의 뺄셈 그림 참조) target.position + -gameObejct.transform.position 로 설명할 수 있으므로
	//위와 같이 현재위치에서 타겟까지의 방향과 거리를 가진 벡터를 추출할 수 있다.
	dir.Normalzie(); //단위벡터로 만들어 방향만을 추출
	dir *= speed * Time.deltaTime; //speed * Time.deltaTime을 통해 1프레임 동안 이동할 거리를 결정
	gameObejct.transform.position += dir; //이동
}
```
<br>

## 벡터와 좌표<br>
벡터의 표현법과 좌표의 표현법이 같다는 것은 이미 눈치를 채고 있을 것이다. <br>
다시 말하면 (3, 1)은 2차원 벡터를 뜻하기도 하지만, 좌표평면위의 한 점 을 뜻한다. <br>
또한 (1, 4, 3)은 3차원 벡터를 뜻하기도 하지만, 공간좌표에서의 한 점 을 뜻하기도 한다. <br>
<br>
![3차원 좌표](https://user-images.githubusercontent.com/43705434/108397938-d705bd00-725b-11eb-9494-c212cef9b673.png)

> 해당 3차원 벡터를 통해 유니티에서 좌표계를 나타낼 수 있다.<br>
<br>
<br>

## 벡터의 내적<br>
내적은 벡터간의 곱셈으로 스칼라곱 또는 Dot Product 라고도 하며, 기호로 · (Dot)을 쓴다.<br>
벡터의 내적을 구하는 방식은 두가지가 존재한다.<br>

1. 좌표값의 각 성분을 곱해서 더하는 방식<br>
A·B = (Ax * Bx) + (Ay * By) + (Az * Bz)
<br>

2. 벡터의 크기를 곱하는 방식 (좀 더 비싼 방식)<br>
A·B = ｜A｜x｜B｜x cosΘ
<br>

벡터의 내적은 벡터간의 투영 길이를 나타내는 의미<br>
또한, 두 벡터간의 각도를 얻을 수 있는 방법을 의미하기도 한다.<br>
-> 게임상에서 적을 타격했을 경우 백어택인지 아니면 일반어택인지 구분하거나<br>
-> 쉐이더에서 빛을 받는 부분인지 아닌지 판별할때 사용할 수 있다.<br>
<br>

### 내적을 이용해 두 벡터사이의 각도를 구하는 방법<br>
A·B = ｜A｜x｜B｜x cosΘ 해당 식에서 ｜A｜x｜B｜로 양변을 나눠준 후 arccos을 취해주게되면<br>
Θ = arccos(A·B / ｜A｜x｜B｜)가 되기 때문에 세타 즉 각도를 구할 수 있게 된다.<br>
<br>
<br>

**tip. 내적을 이용한 백어택 판별**<br>
![내적코사인값](https://user-images.githubusercontent.com/43705434/109042284-5d664700-7713-11eb-8dcb-529ee431cb34.PNG)<br>
A·B = ｜A｜x｜B｜x cosΘ 공식에서 만약 A,B벡터의 길이가 1이라면 cosΘ값에 의해서 결과가 결정될 것이다.<br>
이때 두 벡터가 같은 방향을 바라보고 있다면 세타값이 0이므로 cos0 = 1 값이 나오며<br>
두 벡터가 서로 반대되는 방향을 바라보고 있다면 세타값이 180이므로 cos180 = -1값이 나온다.<br>
또한 두 벡터가 직교한다면 세타값이 90이므로 cos90 = 0값이 나오게된다.<br>
이러한 성질을 이용해보자. 두 벡터를 노말라이즈 한 후 내적연산을 진행하게되면 -1 ~ 0 ~ 1 사이의 값이 나오게 될 것이다.<br>
이 값을 통해서 두 벡터가 같은 방향을 바라보고 있는지, 직교하는지, 마주보고있는지를 판별할 수 있게된다.<br>
예를들자면, 총알의 진행방향(벡터)과 적 오브젝트의 전방방향(벡터)을 내적연산하여 0보다 큰 값이라면 백어택 처리를 해줄 수 있다.<br> 
<br>
<br>

**tip. 내적을 이용한 시야각 구현**<br>
![내적시야각](https://user-images.githubusercontent.com/43705434/109106848-f75ddc00-7773-11eb-87a7-5ab184dd1f60.PNG)<br>
플레이어의 정면을 기준으로 90도 내에 적이 들어올 시 감지하는 기능을 만든다고 가정해보자.<br>
(정면기준 왼쪽 45도 오른쪽 45도 내에 적이 들어와야 할 것이다.)<br>
우선 플레이어가 바라보는 시선벡터와 적과 플레이어의 차이로 나오는 벡터 A 간의 내적을 통해서<br>
코사인값을 얻어낼 수 있을 것이다. (벡터는 노말라이즈) 이때 플레이어의 정면이 시초선이기 때문에,<br>
각도가 정면과 가까워 질수록 코사인값은 1에 가까워져야한다. 그렇기 때문에 벡터 A와의 내적을 통해 얻어낸<br> 
코사인값이 (시야각 / 2) 코사인값보다 크다면 적이 시야각내에 들어와있는 것으로 판단할 수 있다.<br>
<br>
<br>

**tip. 내적을 이용한 앞뒤 구분**<br>
![내적앞뒤구분](https://user-images.githubusercontent.com/43705434/109106844-f62caf00-7773-11eb-89c3-2e10090c240a.PNG)<br>
적이 플레이어의 앞에 존재하는지, 뒤에 존재하는지 판별하는 기능을 만든다고 가정해보자.<br>
플레이어의 정면벡터 즉 forward벡터를 기준으로 좌, 우 90도까지는 적 벡터와의 사잇각을 통해 코사인을 계산하면<br>
무조건 양수값이 나오기 때문에 해당 값을 통해 앞에 존재하는 것을 파악할 수 있다. 하지만 좌우로 90도가 넘어가서<br>
사잇각이 둔각이 된다면 코사인은 무조건 음수값이 나오게 되므로 해당 값을 통해 뒤에 존재한다는 것을 파악할 수 있다.<br>
<br>
<br>

**tip. 내적을 이용한 뒷면 렌더링 제외하기**<br>
![내적렌더링제외](https://user-images.githubusercontent.com/43705434/119091767-84998f80-ba48-11eb-8e5d-37164758dcbe.PNG)<br>
위 그림은 정육면체를 3D 그래픽으로 렌더링 한 모습이다.<br>
왼쪽 그림을 보면 정육면체의 면들 중 단 두 개의 면만 화면에 렌더링 되고 있는 것을 알 수 있다.<br>
<br>

검은색으로 그려진 선은 각 폴리곤으로부터 카메라쪽으로 향하는 벡터를 나타낸 것이며 파란색 화살표는 법선벡터이다.<br>
그림으로 봤을 때 이 두 벡터 사이의 각도가 90도 이하면 해당 폴리곤은 카메라쪽을 바라보고 있다고 판단할 수 있다. (a, b)<br>
<br>

반대로 각도가 90도 보다 크면 카메라를 등지고 있다고 판단할 수 있다. (c, d)<br>
카메라를 등지고 있는 폴리곤은 어차피 보이지 않을 것이므로 계산에서 제외한다면 렌더링 성능이 훨씬 올라갈 것이다.<br>
<br>
<br>

**tip. 내적을 이용한 반사벡터 구하기**<br>
내적을 이용하면 반사벡터도 쉽게 구할 수 있다.<br>
벽에 부딪힌 당구공이 어느 방향으로 튕겨 나가는지 상상해 본다면 반사벡터의 모습이 머릿속으로 그려질 것이다.<br>
<br>

이러한 반사벡터는 다음과 같이 구할 수 있다. (velocity가 공의 속도벡터)<br>
> Vector3 reflect = velocity + 2 * normal * Vector3.Dot(-velocity, normal);<br>
<br>

이 공식이 어떻게 유도되는지 살펴보자.<br>
![반사벡터1](https://user-images.githubusercontent.com/43705434/119091757-82373580-ba48-11eb-8779-e8667386b670.PNG)<br>
![반사벡터2](https://user-images.githubusercontent.com/43705434/119091760-83686280-ba48-11eb-83ff-8e4e3050325a.PNG)<br>
![반사벡터3](https://user-images.githubusercontent.com/43705434/119091761-83686280-ba48-11eb-85a1-a2dd8be52a98.PNG)<br>
![반사벡터4](https://user-images.githubusercontent.com/43705434/119091762-8400f900-ba48-11eb-83ce-9648efcb9779.PNG)<br>
![반사벡터5](https://user-images.githubusercontent.com/43705434/119091766-8400f900-ba48-11eb-8562-21b4baa4563b.PNG)<br>
<br>

여기서 이해해야 할 부분은 벡터의 내적을 통해서 한 벡터가 다른 벡터에 투영된 길이를 알 수 있다는 것이다.<br>
반사벡터를 구할 때 벡터 -p를 벽의 법선 벡터인 n과 내적 하여 계산했는데,<br>
이 내적의 결과로 나온 값은 벡터 -p를 법선 벡터 n에 투영한 길이가 된다.<br>
(단, 법선 벡터 n은 반드시 단위 벡터 상태로 되어 있어야 한다.)<br>
<br>

**2를 곱해주는 이유?**<br>
위 수식을 풀어보면, 2 * n * (-p∙n) 이다.<br>
n * (-p∙n) 만 먼저 계산해 보면 (-p∙n) = 스칼라값이고 여기에 n을 곱하면 벡터 n의 길이는<br> 
위 그림에서 벡터 -p의 높이성분과 같은 길이를 갖게 된다.<br>
여기에 2를 곱하면 길이가 두배로 늘어난 벡터가 된다.<br> 
이걸 벡터 p와 더해주면 입사각과 똑같은 크기를 가진 반사벡터가 생기게 된다.<br>
<br>

만약 2를 곱하지 않는다면?<br>
벡터 n의 길이는 벡터 -p를 n에 투영한 만큼의 길이를 갖게 되므로(마지막 그림에서 점선 부분)<br>
최종적으로 구해지는 반사벡터는 벽면에 평행한 벡터가 되기 때문에 원하는 반사벡터를 구할 수 없게 된다.<br>
<br>

## 벡터의 외적<br>
![외적좌표계](https://user-images.githubusercontent.com/43705434/109163803-12a10980-77bd-11eb-945e-2c431a428c28.PNG)<br>
<br>
내적을 기하학적인 의미로 봤을 때, 두 벡터가 이루는 각이라면, 외적은 기하학적으로 볼때<br>
두 벡터 모두에게 수직인 벡터를 의미한다.<br>

이러한 또다른 벡터의 곱셈인 외적은 Cross Product라고도 하며, 기호로 X (Cross)를 사용한다.<br>
또한 내적은 2차원, 3차원에서 사용될 수 있으나, 외적은 3차원 이상에서만 의미를 가진다.<br>
그 이유는 내적은 결과값으로 스칼라를 반환하지만, 외적은 두 벡터와 직교하는 벡터를 반환하기 때문이다.<br>
<br>
공식1<br>
![외적공식1](https://user-images.githubusercontent.com/43705434/109163807-146acd00-77bd-11eb-8d71-a07e5983c37b.PNG)<br>
<br>

공식2<br>
![외적공식2](https://user-images.githubusercontent.com/43705434/109163818-159bfa00-77bd-11eb-840d-ca6b6bf5f5bc.PNG)<br>
<br>
<br>

**외적의 특징**
1. 외적한 결과값과 A, B중 하나와 내적을하게되면 직교하므로 0값이 나오게 된다.<br>
2. 벡터의 내적 같은 경우 교환법칙이 성립하지만, 외적은 곱하는 순서가 중요하다.<br>
3. 외적의 결과값으로 나온 벡터 C의 크기는 A와 B를 연결한 평행사변형의 넓이와 같다.<br>
4. 외적도 내적과 마찬가지로 주로 단위벡터와 함께 사용하는데, 이때 외적값인 벡터 C의 크기로 A와 B의 사이각을 판단할 수 있다.<br>
-> 벡터 C의 크기가 1이라면 A와 B를 연결해서 만든 도형이 가로세로 1인 정사각형임. 고로 A,B는 수직<br>
-> 벡터 C의 크기가 0이라면 두 벡터가 일치하거나 방향이 반대임을 알 수 있다.<br>
<br>

**tip. 외적을 이용한 법선벡터(평면에 수직인 벡터)  구하기**<br>
![외적법선벡터](https://user-images.githubusercontent.com/43705434/109163822-16cd2700-77bd-11eb-977f-19f50c4a0da5.PNG)<br>
<br>
이러한 외적은 법선벡터를 구하는데 사용될 수 있는데, 예를들어 삼각형의 세 점을 알고 있다면<br>
차를 통해 벡터 2개를 구할 수 있게 되고 그 두 벡터를 외적하면 해당 평면의 법선 벡터를 구할 수 있다.<br>
-> 이는 두 벡터와 직교하는 외적값의 성질을 이용한 것이다.<br>
<br>

**tip. 외적을 이용한 점과 직선사이의 거리 구하기**<br>
![외적평행사변형](https://user-images.githubusercontent.com/43705434/109163834-19c81780-77bd-11eb-9798-7709dc2f8105.PNG)<br>
<br>

![외적점과직선사이거리](https://user-images.githubusercontent.com/43705434/109163825-17fe5400-77bd-11eb-9a46-a33e7e8ca6aa.PNG)<br>
<br>

위에서 외적의 결과는 두 벡터를 연결한 평행사변형의 넓이와 같다고 설명한것을 볼 수 있다<br>
이를 이용해서 점과 직선사이의 거리를 구할 수 있다. 위 그림을 참고해보자면 S직선과 A라는 점이 있을때<br>
A와 S사이의 거리를 구하고 싶다면 BC벡터와 BA벡터를 구해 두 벡터의 외적을 계산한다.<br>
그렇게되면 그림에 나오는 것처럼 평행사변형의 넓이를 구하게 되는 꼴인데, 이때 BC로 나눠주게되면<br>
평행사변형의 넓이 = 밑변 X 높이 이므로 즉 밑변으로 양변을 나눠준 꼴이 되기 때문에<br> 
결과값인 ｜BA｜sinΘ는 높이가 되게 된다. 해당 높이는 점과 직선사이의 거리와 같다.<br>

> 이를 응용해보자면 레이저를 쐈을때 레이저와 가장 가까운 적을 구해낼 수 있을 것이다.<br>
<br>

**tip. 외적을 이용한 좌,우 구별하기**<br>
https://blog.naver.com/bsheep91/221493257577<br>
![내적외적코드](https://user-images.githubusercontent.com/43705434/109163830-1896ea80-77bd-11eb-95e2-22bf38715530.PNG)<br>
(위 코드는 외적의 결과로 나온 벡터의 y축 값을 통해서 좌우를 구별)<br>
<br>

**(아래 설명은 아직 완전하지 못함. 이해한대로만 설명한 부분이기 때문에 추후에 대폭 수정될 부분들임 고로 밑에 설명 참고)**
플레이어의 정면벡터 A와 목표물의 위치벡터와 플레이어 벡터의 차를 통해 구해낸 목표물까지의 벡터 B를<br>
노말라이즈 한 후 외적하게되면 ｜A｜x｜B｜x sinΘ 공식에의해 sinΘ 값 즉 두 벡터의 사잇각에 따른 사인값이<br>
최종결과가 되게 된다. 플레이어의 정면벡터를 시초선으로 하기 때문에 사인함수의 특성상 -180도 ~ 0도는 음수값<br>
0도 ~ 180도 까지는 양수값을 가지게 된다. 고로 목표물이 오른쪽에 있으면 양수값, 왼쪽에 있으면 음수값을<br>
반환하게 된다. 고로 외적의 결과를 통해서 목표물이 플레이어 기준 왼쪽에 위치하는지 오른쪽에 위치하는지<br>
알아낼 수 있게 된다.<br>

**위 설명은 완전하지 못하기에 블로그를 참고하여 설명할 것임.**<br>
우선 유니티는 왼손좌표계를 사용하기 때문에, 일반 수학과는 반대로 생각해야한다.<br>
우선 플레이어의 정면벡터가, 즉 앞벡터 A가 기준벡터가 되어야 할 것이다.<br>
그 후, 목표물까지의 벡터 즉 플레이어에서 목표물까지의 방향벡터 B를 구한다.<br>
A X B 즉 외적을 계산해준다. 이때 B가 오른쪽에 위치한다면 왼손좌표계에 의해서 말아쥐어줘야하는<br>
방향이 오른쪽이기 때문에 엄지는 위를 향한다. 즉 외적의 결과 벡터의 Y값은 양수이다.<br>
만약 B가 왼쪽에 위치한다면 왼손좌표계에 의해서 말아쥐어야하는 방향은 왼쪽이기 때문에 엄지는 아래를 향한다.<br>
즉 외적의 결과 벡터의 Y값은 음수라는 것이다. 이를 통해서 외적의 결과 벡터의 Y값이 음수냐 양수냐에 따라<br>
목표물이 플레이어 기준 왼쪽에 위치하는지 오른쪽에 위치하는지 알아낼 수 있다.<br>
<br>

외적과 쿼터니언<br>
유니티에서의 벡터<br>
<br>

## 원주율<br>
원주율은 벡터와 연관이 있기 때문에 알고 있어야 한다.<br>
pi = 3.14라는 사실은 누구나 알고 있을 것이다.<br>
하지만 pi가 어떤것을 의미하는지 제대로 알아야한다.<br>

원주 : 원의 둘레<br>
원주율 : 원주 / 지름<br>
즉 원주율이란 지름을 기준으로, 원주 길이의 비율을 의미한다.<br>

> 지름이 1이라면 원주의 길이는 3.14가 될 것.<br>

이러한 원주율은 지름과 원주사이의 일정한 비율이기 때문에, 원의 크기가 아무리 달라져도 절대 변하지 않는다.<br>
때문에 원의 가장 중요한 특징이라고 할 수 있다.<br>

-> 유도되는 공식들<br>
지름 = 원주 / 원주율<br>
원주 = 지름 x 원주율<br>

ex) 314m 운동장을 지름 100cm 굴렁쇠로 한바퀴 돌려면 몇 바퀴를 굴려야 할까?<br>

굴렁쇠의 원주 = 100 x 3.14 = 314cm<br>
-> 100바퀴를 굴리면 운동장 한바퀴를 돌게된다.<br>
<br>

## 라디안<br>
60분법 : 0 ~ 360 (Degree)<br>
**호도법 : 라디안 (Radian)**<br>
호의 길이로써 각도를 표현해주는것을 호도법이라고 한다.<br>
호도법에서는 각도를 세타(Θ)로 표현한다.<br>

![라디안](https://user-images.githubusercontent.com/43705434/108589491-df681000-73a1-11eb-9399-463363e3635a.png)<br>

> 정의 하기를, 호의 길이가 1이고 반지름도 1일때의 라디안(각도)을 1라디안으로 정의한다.<br>
<br>

![파이라디안](https://user-images.githubusercontent.com/43705434/108589492-e0993d00-73a1-11eb-9a99-62c678717ffb.png)<br>
<br>
![파이반원주](https://user-images.githubusercontent.com/43705434/108589494-e0993d00-73a1-11eb-978a-5127af816a53.png)<br>
<br>

반지름이 1인 원에서 pi = 원주 / 지름이며<br>
pi = (원주/2) / (지름/2)으로 표현하게되면 pi = 반원주 라는 식이 성립하게 된다.<br>
즉 pi로 반원주를 나타내게 되는 것이다. 이때 반원주는 180도이기 때문에 pi로 180도를 나타낼 수 있게된다.<br>
<br>

**또다른 설명**<br>
1라디안의 정의는 위에서 볼 수 있듯이 반지름과 호의길이가 같을때를 1라디안으로 정의한다.<br>
만약 호의길이가 2배가된다면 2라디안이 될 것이다. 이 말은 즉슨 호의길이가 반지름의 몇배인지를 판단하면 라디안값이 나온다는것이다.<br>
반원의 둘레는 pi x r이니까 r x (몇 배) = pi x r로 나타낼 수 있을 것이다. -> 반원의 둘레가 반지름의 몇배인지 알아보는것.<br>
결국 (몇 배)에 들어갈 값은 pi라는 것을 알 수 있다. 이때 위에서 정의했듯이 반지름의 몇배가 호의길이인지를 알면 라디안을 안다고했는데<br>
이는 r x 라디안 = pi x r 라는 식이 성립하는것이므로 r x (몇 배) = pi x r 식과 동일하다. 즉 r x pi = 반둘레의 길이가 되는 것이다.<br>
이를 통해서 라디안에 들어갈 값이 pi라는 것 즉 180도가 pi로 대체될 수 있다는 것을 알 수 있고 해당 값을 통해서 여러 각들을 실수체계로 표현할 수 있게된다.<br>
https://www.youtube.com/watch?v=jwqZ9WFN5Vk<br>
<br>

![파이각도](https://user-images.githubusercontent.com/43705434/108589495-e131d380-73a1-11eb-81c3-e53c9ff450e8.png)<br>
고로 해당 pi를 통해 위와같이 여러 각도를 표현할 수 있다.<br>
<br>
<br>

![라디안투디그리](https://user-images.githubusercontent.com/43705434/108589496-e131d380-73a1-11eb-9b56-6fbc62e3221e.png)<br>
Unity에서 함수로 제공<br>
Mathf.Rad2Deg : 라디안 -> 디그리 변환.<br>
Mathf.Deg2Rad : 디그리 -> 라디안 변환.<br>
<br>

## 삼각함수<br>
삼각함수는 쉽게 말해서 삼각비 + 호도법 + 함수이다. 즉 삼각비에서 직각삼각형 세 변의 길이의 비는<br>
각에 대한 일정한 관계를 가지는데, 이 일정한 관계를 함수로 나타낸 것이 삼각함수이다.<br>
또한 삼각함수에서는 호도법으로 각을 나타내어 사용하는데, 이는 삼각함수는 전부 좌표평면상에서 표현이되는데 즉 실수체계라는것이다.<br>
그리하여 각도 또한 실수체계로 바꿔야 하기 때문에 호도법을 사용하는것이다.<br>

> 좌표평면 상 점의 좌표를 삼각함수로 표현한다!<br>
<br>

### 삼각비<br>
삼각비란 직각삼각형에서 세 변들 사이의 비율을 말한다.<br>
종류로는 sin, cos, tan, cosec, sec, cot가 존재한다.<br>
<br>
![삼각비](https://user-images.githubusercontent.com/43705434/108827841-708cf000-7609-11eb-879e-8eb4dfb79174.PNG)<br>
<br>
<br>

특수각에 대한 삼각함수 값<br>
![삼각함수특수각값](https://user-images.githubusercontent.com/43705434/108827846-71be1d00-7609-11eb-9d88-21684f3e6c77.PNG)<br>
<br>

> 빗변의 길이, 즉 원의 반지름을 1로 가정할때 sin = y, cos = x 값이 되므로<br>
> tan = y/x 가 된다. **즉 탄젠트값을 기울기라고 정의할 수 있겠다.**<br>
<br>
<br>

**tip.**<br>
![image](https://user-images.githubusercontent.com/43705434/108835453-d5007d00-7612-11eb-8d72-1c009945486a.png)<br>
<br>

위 공식에 의해서 **단위원 상에서의** sin값은 y좌표 cos값은 x좌표로 사용할 수 있다.
Unity에서 특정 각에 대한 오브젝트의 진행방향에 대해서 얘기할때, sin 값을 y좌표 cos을 x좌표으로 사용할 수 있다.<br>
-> 이는 tan로 각도를 주는것과 동일하게 동작하지만, 오브젝트를 이동시킬때 vector3로써 방향과 속력을 줘야하기 때문.<br>
<br>

### 역삼각함수<br>
일반적인 삼각함수의 반대 기능을 하는 역삼각함수들도 존재한다.<br>
arcsin, arccos, arctan 등이 그 예이다.<br>
이러한 역삼각함수는 여러 방면에서 용이하게 사용될 수 있다.<br>
<br>

> 2D게임에서 오브젝트가 특정 방향(대각선)으로 물리이동을 진행중일때, 해당 방향에 걸맞는 각도로 오브젝트를 z축 회전시켜주려면
> Mathf.Atan(dir.y / dir.x) * Mathf.Rad2Deg; 를 통해서 해당 각도를 구해줄 수 있을 것이다. <br>
<br>
<br>

**tip.**<br>
위 명령문을 통해서 각도를 구해낼 수 있는것은 tanΘ = y / x일때, 탄젠트의 역삼각함수인 아크탄젠트를 양변에 취해주면,<br>
Θ = arctan( y / x )를 통해서 해당 각도값을 구해낼 수 있기 때문이다.<br>
-> 위에서 설명했던 sin ,cos 값을 통해서 오브젝트의 진행방향을 구하는 예와 동일한 경우다.<br>
**각도를 구하느냐, 벡터를 구하느냐의 차이**<br>

**삼각함수 사용 tip에 대해 정확히 같은 내용을 설명해주는 글을 찾게되어 링크를 올려놓음**<br>
https://zzoyu.tistory.com/73<br>
<br>

### 제1,2 코사인법칙<br>
![제1,2 코사인법칙](https://user-images.githubusercontent.com/43705434/109030435-2722ca80-7707-11eb-9741-6d587b4a0fe5.PNG)<br>
<br>

**제1 코사인법칙 증명**<br>
![제1코사인삼각형](https://user-images.githubusercontent.com/43705434/109030430-25f19d80-7707-11eb-9211-ac631df41947.PNG)<br>
<br>

삼각형에 수선을 내려그어, 두 직각삼각형으로 나누었다고 가정해보자.<br>
이때 a = BH + CH 라는 점을 기억하자.<br>
<br>

ABH 삼각형에서 cosB = BH / c 가 되고 BH = ccosB 가 된다.<br>
ACH 삼각형에서 cosC = CH / b 가 되고 CH = bcosC 가 된다.<br>
결국 a = BH + CH = bcosC + ccosB라는 것을 알 수 있다.<br>
<br>

**제2 코사인법칙 증명**<br>
우선 제1 코사인법칙의 3가지 식 양변에 좌변에 있는 항목을 곱해준다.<br>
a² = abcosC + accosB<br>
b² = bccosA + bacosC<br>
c² = cacosB + cbcosA<br>
이 성립한다.<br>

그후 a² - b² - c²을 계산하면 a² - b² - c² = abcos +accosB - (bccosA + bacosC) - (cacosB + cbcosA)이며, <br>
-> a² - b² - c² = -2bccosA<br>
-> a² = b² + c² -2bccosA 이 성립하게된다.<br>
<br>

### 참조링크<br>
https://www.youtube.com/watch?v=9F4PZ_1orF0 (선형결합, 생성, 선형종속 및 독립, 기저벡터)<br>
https://angeloyeo.github.io/ (행렬식의 기하학적의미, 고유값과 )<br>
https://wergia.tistory.com/161 (유니티 좌표계)<br>
https://wergia.tistory.com/209 (벡터의 연산)<br>
http://lab.gamecodi.com/board/zboard.php?id=GAMECODILAB_Lecture_series&no=125 (내적을 이용한 렌더링제외, 반사벡터) <br>
