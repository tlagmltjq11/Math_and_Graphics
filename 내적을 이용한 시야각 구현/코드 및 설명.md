## 내적을 이용한 시야각 구현<br>

**코드**<br>

```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class AngleOfView : MonoBehaviour
{
    #region Field
    public float m_viewAngle;    //시야각
    public float m_viewDistance; //시야거리
    public float m_speed; //이동속도
    public float m_rotSpeed; //회전속도

    public LayerMask m_targetMask;    //Enemy 레이어마스크 지정을 위한 변수
    public LayerMask m_obstacleMask;  //Obstacle 레이어마스크 지정 위한 변수

    private Transform m_transform; //Player Transform
    #endregion

    #region Unity Methods
    void Awake()
    {
        m_transform = GetComponent<Transform>();
    }

    void Update()
    {
        Move(); //움직임처리
        DrawView();             //Scene뷰에 시야범위 그리기
        FindVisibleTargets();   //Enemy인지 Obstacle인지 판별
    }
    #endregion

    #region Public Methods
    public void Move()
    {
        var amtToMove = m_speed * Time.deltaTime; // 프레임에 이동할 거리
        var amtToRot = m_rotSpeed * Time.deltaTime; // 프레임에 회전할 각도

        var move = Input.GetAxis("Vertical"); // 전후진
        var angle = Input.GetAxis("Horizontal"); // 좌우 회전 방향

        if(move < 0)
        {
            angle *= -1;
        }

        transform.Translate(Vector3.forward * move * amtToMove); // 탱크 전후진
        transform.Rotate(new Vector3(0, angle * amtToRot, 0)); // 탱크 회전
    }

    public Vector3 DirFromAngle(float angleInDegrees)
    {
        //탱크의 좌우 회전값 갱신
        angleInDegrees += transform.eulerAngles.y;
        //경계 벡터값 반환
        return new Vector3(Mathf.Sin(angleInDegrees * Mathf.Deg2Rad), 0, Mathf.Cos(angleInDegrees * Mathf.Deg2Rad));
    }

    public void DrawView()
    {
        //시야각을 그려준다.
        Vector3 leftBoundary = DirFromAngle(-m_viewAngle / 2);
        Vector3 rightBoundary = DirFromAngle(m_viewAngle / 2);

        Debug.DrawLine(m_transform.position, m_transform.position + leftBoundary * m_viewDistance, Color.green);
        Debug.DrawLine(m_transform.position, m_transform.position + rightBoundary * m_viewDistance, Color.green);
    }

    public void FindVisibleTargets()
    {
        //시야거리 내에 존재하는 모든 오브젝트의 콜라이더 받아오기
        //OverlapSphere 플레이어 위치를 원점으로 시야거리만큼의 반지름을 갖는 원을 그려 해당 내에 포함되는 오브젝트들을 감지하는 메소드임.
        Collider[] targets = Physics.OverlapSphere(m_transform.position, m_viewDistance, m_targetMask);

        //감지된 모든 타겟에 대해서 반복문 실행
        for (int i = 0; i < targets.Length; i++)
        {
            //타겟의 위치를 받아옴.
            Transform target = targets[i].transform;

            //탱크로부터 타겟까지의 방향을 벡터의 뺄셈을 통해 구해준 후 방향만 사용해도 되니 단위벡터로 만들어준다.
            Vector3 dirToTarget = (target.position - m_transform.position).normalized;

            //m_transform.forward와 dirToTarget은 모두 단위벡터이므로 내적값은 두 벡터가 이루는 각의 Cos값과 같다. -> cos값으로 비교해주면 된다는 뜻
            //내적값이 시야각/2의 Cos값보다 크면 시야에 들어온 것이다.
            if (Vector3.Dot(m_transform.forward, dirToTarget) > Mathf.Cos((m_viewAngle / 2) * Mathf.Deg2Rad))
            {
                float distToTarget = Vector3.Distance(m_transform.position, target.position);

                //시야거리 내에서 감지되었으며, 시야각 내에 존재하는 target에게 Ray를 발사
                //이때 장애물에 맞았다면 if문 내로 들어가지 않는다.
                if (!Physics.Raycast(m_transform.position, dirToTarget, distToTarget, m_obstacleMask))
                {
                    //시야각이 제대로 작동되는지 보여주기 위해 Line을 그려준다.
                    Debug.DrawLine(m_transform.position, target.position, Color.red);
                }
            }
        }
    }
    #endregion
}
```


